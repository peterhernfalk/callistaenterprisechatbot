<!DOCTYPE html>
<html lang="sv-se">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Callista Enterprise - seniora IT-arkitekter och systemutvecklare inom Java, öppen källkod, agil utveckling och systemintegration">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
    <meta name="viewport" content="initial-scale=1.0001, minimum-scale=1.0001, maximum-scale=1.0001, user-scalable=no"/>

    <link rel="icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="shortcut icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="apple-touch-icon" href="../../../../../../images/icons/callista_favicon_160x160.png">

    <title>Go Microservices blog series, part 10 - centralized logging. | Callista</title>

    <link rel="stylesheet" href="../../../../../../css/style.css%3Fv=1.css">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for callistaenterprise.se" href="../../../../../../feed.xml" />

    <!--[if lte IE 8]>
    <style>* { display: none !important; }</style>
    <meta http-equiv="refresh" content="0; url=/oldie/"/>
    <![endif]-->

    <script type="text/javascript" src="https://use.typekit.net/kig5egm.js"></script>
    <script type="text/javascript">
        try {
            Typekit.load({ async: true });
        } catch (e) {
        }
    </script>

    <!-- Facebook Pixel Code -->
    <script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window,document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
     fbq('init', '804675599711872');
     fbq('track', 'PageView');
    </script>
    <noscript>
     <img height="1" width="1" src="https://www.facebook.com/tr?id=804675599711872&ev=PageView&noscript=1"/>
    </noscript>
    <!-- End Facebook Pixel Code -->

</head>
<body>

    <header class="ce-header" data-scroll="0">
    <nav>
        <img alt="menubg" class="ce-menu-icon" style="z-index:3; top: 0px; width: 50px; height: 100%;" src="../../../../../../images/icons/menu_background.png">
        <a class="ce-logotype" href="../../../../../../index.html" style="z-index: 2;">
            <img alt="Callista" style="max-width: 100%; height: auto;" src="../../../../../../images/logotype/callista_small2.svg">
        </a>
        <table>
            <tr>
                <td>
            <ul id="menu-primary" class="ce-menu-primary">
                
                    
                            <li><a href="../../../../../../om/index.html">Om oss</a></li>
                    
                
                    
                            <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                    
                
                    
                            <li><a href="../../../../../../event.html">Event</a></li>
                    
                
                    
                        
                            <li><a class="ce-active" href="../../../../../../blogg.html">Blogg</a></li>
                        
                    
                
                    
                            <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                    
                
            </ul>
                </td>

                <td>
            <ul class="ce-menu-secondary">
                
                <li><a href="../../../../../../english/index.html">English</a></li>
                
            </ul>
                </td>
            </tr>
        </table>
            <a id="menu" class="ce-menu-icon" href="../go-blog-series-part10.html#" style="z-index: 4;">
                <img alt="Visa meny" src="../../../../../../images/icons/menu.png">
            </a>
            <a class="ce-search-icon" href="../go-blog-series-part10.html#">
                <img alt="Sök" src="../../../../../../images/icons/search.png">
            </a>

        </table>
    </nav>
</header>


    <div class="ce-main">
        <section class="ce-start lazyImg">
    <article>
        <h1>Blogg</h1>
        <p class="ce-ingress">
            Här finns tekniska artiklar, presentationer och nyheter om arkitektur och systemutveckling. Håll dig uppdaterad, följ oss på <a class="ce-active" href="http://twitter.com/callistaent">Twitter</a>
        </p>
    </article>
</section>

<section class="ce-section">
    <div class="ce-content">
        
        

        
        

        <article class="ce-blog">
            <header>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <img alt="Callista medarbetare Erik Lupander" src="../../../../../../assets/medarbetare/eriklupander_mini.png">
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <h2>
        <a href="../go-blog-series-part10.html">Go Microservices blog series, part 10 - centralized logging.</a>
        
        
    </h2>
    <h3>
        <time datetime="2017-08-02T00:00:00+00:00">
            02 August 2017
        </time>
        //
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        <a href="../../../../../../om/medarbetare/eriklupander/index.html">Erik Lupander</a>
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </h3>
    
</header>




<p>In this part of the Go microservices <a href="../../../02/17/go-blog-series-part1.html">blog series</a>, we’ll introduce a logging strategy for our Go microservices based on <a href="https://github.com/sirupsen/logrus">Logrus</a>, the Docker <a href="https://docs.docker.com/engine/admin/logging/gelf/">Gelf logging driver</a> and the “Logging as a Service” service <a href="https://www.loggly.com/">Loggly</a>.</p>

<h1 id="introduction">Introduction</h1>
<p>Logs. You never know how much you miss them until you do. Having guidelines for your team about what to log, when to log and how to log, may be one of the key factors for producing a maintainable application. Then, microservices happen.</p>

<p>While dealing with one or a few different log files for a monolithic application is usually manageable (though exceptions exist…), consider doing the same for a microservice-based application with potentially hundreds or even thousands of service containers each producing logs. Don’t even consider going big if you don’t have a solution for collecting and aggregating your logs in a well-structured manner.</p>

<p>Thankfully, a lot of smart people have already thought about this - the stack formerly know as ELK is perhaps one of the most well-known within the open source community. ElasticSearch, LogStash and Kibana forms the <a href="https://www.elastic.co/webinars/introduction-elk-stack">Elastic Stack</a> which I recommend for both on-premise and cloud deployments. However, there probably exists dozens of blog posts about ELK, so in this particular blog, we’ll explore a <a href="https://en.wikipedia.org/wiki/Logging_as_a_service">LaaS</a> (Logging as a Service) solution for our centralized logging needs based on four parts:</p>

<h3 id="contents">Contents</h3>
<ol>
  <li>Logrus - a logging framework for Go</li>
  <li>Docker GELF driver - logging driver for the Greylog Extended Log Format</li>
  <li>“Gelftail” - a lightweight log aggregator we’re going to build in this blog post. Of course, we’ll write it in Go.</li>
  <li>Loggly - a <a href="https://en.wikipedia.org/wiki/Logging_as_a_service">LaaS</a> provider. Provides similar capabilities for managing and acting on log data as similar services.</li>
</ol>

<h3 id="solution-overview">Solution overview</h3>
<p><img src="../../../../../../assets/blogg/goblog/part10-overview2.png" alt="overview" /></p>

<h3 id="source-code">Source code</h3>

<p>The finished source can be cloned from github:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; git clone https://github.com/callistaenterprise/goblog.git
&gt; git checkout P10
</code></pre></div></div>

<p><em>Note: Most of the Go source code for the blog series was rewritten in July 2019 to better reflect contemporary idiomatic Go coding guidelines and design patterns. However, the corresponding <a href="https://github.com/callistaenterprise/goblog/tree/P10">git branch</a> for each part of the series remains unchanged in order to stay aligned with the content of each installment. For the latest and greatest code, look at the <a href="https://github.com/callistaenterprise/goblog">master</a> branch in github.</em></p>

<h1 id="1-logrus---a-logging-api-for-go">1. Logrus - a logging API for Go.</h1>

<p>Typically, our Go microservices has up until now logged using either the “fmt” or the “log” packages, either to stdout or stderr. We want something giving us more fine-granular control of log levels and formatting. In the Java world, many (most?) of us have dealt with frameworks such as log4j, logback and slf4j. <a href="https://github.com/sirupsen/logrus">Logrus</a> is our logging API of choice for this blog series, it roughly provides the same type of functionality as the APIs I just mentioned regarding levels, formatting, hooks etc.</p>

<h3 id="using-logrus">Using logrus</h3>
<p>One of the neat things with logrus is that it implements the same interface(s) we’ve used for logging up until now - <em>fmt</em> and <em>log</em>. This means we can more or less use logrus as a drop-in replacement. Start by making sure your GOPATH is correct before fetching logrus source so it’s installed into your GOPATH:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; go get github.com/sirupsen/logrus
</code></pre></div></div>

<h3 id="update-source">Update source</h3>
<p>We’ll do this the old-school way. For <em>/common</em>, <em>/accountservice</em> and <em>/vipservice</em> respectively - use your IDE or text editor to do a global search&amp;replace where <em>fmt.*</em> and <em>log.*</em> are replaced by <em>logrus.*</em>. Now you should have a lot of <em>logrus.Println</em> and <em>logrus.Printf</em> calls. Even though this works just fine, I suggest using logrus more fine-granular support for severities such as INFO, WARN, DEBUG etc. For example:</p>

<table>
  <tbody>
    <tr>
      <td>fmt</td>
      <td>log</td>
      <td>logrus</td>
    </tr>
    <tr>
      <td>Println</td>
      <td>Println</td>
      <td>Infoln</td>
    </tr>
    <tr>
      <td>Printf</td>
      <td>Printf</td>
      <td>Infof</td>
    </tr>
    <tr>
      <td>Error</td>
      <td> </td>
      <td>Errorln</td>
    </tr>
  </tbody>
</table>

<p>There is one exception which is <em>fmt.Error</em> which is used to produce <em>error</em> instances. Do not replace <em>fmt.Error</em>.</p>

<h3 id="update-imports-using-goimports">Update imports using goimports</h3>
<p>Given that we’ve replaced a <em>lot</em> of <em>log.Println</em> and <em>fmt.Println</em> with <em>logrus.Println</em> (and other logging functions), we have a lot of unused imports now that’ll give us compile errors. Instead of fixing the files one at a time, we can use a niftly little tool that can be downloaded and executed on the command-line (or integrated into your IDE of choice) - <a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a>.</p>

<p>Again, make sure your GOPATH is correct. Then use <em>go get</em> to download goimports:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go get golang.org/x/tools/cmd/goimports
</code></pre></div></div>

<p>This will install goimports into your $GOPATH/bin folder. Next, you can go to the root of the <em>accountservice</em> or <em>vipservice</em> service, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd $GOPATH/src/github.com/callistaenterprise/goblog/accountservice
</code></pre></div></div>

<p>Then, run goimports, telling it to fix imports recursively with the “-w” flag which applies the changes directly to the source files.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$GOPATH/bin/goimports -w **/*.go
</code></pre></div></div>

<p>Repeat for all our microservice code, including the <em>/common</em> folder.</p>

<p>Run <em>go build</em> to make sure the service compiles.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go build
</code></pre></div></div>

<h2 id="configuring-logrus">Configuring logrus</h2>

<p>If we don’t configure Logrus at all, it’s going to output log statements in plain text. Given:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logrus.Infof("Starting our service...")
</code></pre></div></div>

<p>It will output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO[0000] Starting our service... 
</code></pre></div></div>

<p>Where <em>0000</em> is the number of seconds since service startup. Not what I want, I want a datetime there. So we’ll have to supply a formatter.</p>

<p>The <em>init()</em> function is a good place for that kind of setup:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func init() {
	logrus.SetFormatter(&amp;logrus.TextFormatter{
		TimestampFormat: "2006-01-02T15:04:05.000",
		FullTimestamp: true,
	})
}
</code></pre></div></div>

<p>New output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO[2017-07-17T13:22:49.164] Starting our service...
</code></pre></div></div>

<p>Much better. However, in our microservice use-case, we want the log statements to be easily parsable so we eventually can send them to our <a href="https://en.wikipedia.org/wiki/Logging_as_a_service">LaaS</a> of choice and have the log statements indexed, sorted, grouped, aggreagated etc. Therefore we’ll want to use a JSON formatter instead whenever we’re <em>not</em> running the microservice in standalone (i.e. -profile=dev) mode.</p>

<p>Let’s change that <em>init()</em> code somewhat so it’ll use a JSON formatter instead unless the “-profile=dev” flag is passed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func init() {
    profile := flag.String("profile", "test", "Environment profile")
	if *profile == "dev" {
		logrus.SetFormatter(&amp;logrus.TextFormatter{
			TimestampFormat: "2006-01-02T15:04:05.000",
			FullTimestamp: true,
		})
	} else {
		logrus.SetFormatter(&amp;logrus.JSONFormatter{})
	}
}
</code></pre></div></div>

<p>Output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"level":"info","msg":"Starting our service...","time":"2017-07-17T16:03:35+02:00"}
</code></pre></div></div>

<p>That’s about it. Feel free to read the Logrus <a href="https://godoc.org/github.com/sirupsen/logrus">docs</a> for more comprehensive examples.</p>

<p>It should be made clear that the standard logrus logger doesn’t provide the kind of fine-granular control you’re perhaps used to from other platforms - for example changing the output from a given <em>package</em> to DEBUG through configuration. It is however possible to create scoped logger instances which makes more fine-grained configuration possible, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var LOGGER = logrus.Logger{}   // &lt;-- Create logger instance

func init() {
	// Some other init code...
	
	// Example 1 - using global logrus API
	logrus.Infof("Successfully initialized")
	
	// Example 2 - using logger instance
	LOGGER.Infof("Successfully initialized")
}
</code></pre></div></div>

<p><em>(example code, not in repo)</em></p>

<p>By using a <em>LOGGER</em> instance it’s possible to configure the application-level logging in a more fine-granular way. However, I’ve chosen to do “global” logging for now using <em>logrus.*</em> for this part of the blog series.</p>

<h1 id="2-docker-gelf-driver">2. Docker GELF Driver</h1>
<p>What’s GELF? It’s an acronym for <a href="http://docs.graylog.org/en/2.2/pages/gelf.html">Greylog Extended Log Format</a> which is the standard format for <a href="https://www.elastic.co/products/logstash">logstash</a>. Basically, it’s logging data structed as JSON. In the context of Docker, we can configure a Docker Swarm Mode <em>service</em> to do its logging using various <a href="https://docs.docker.com/engine/admin/logging/overview/">drivers</a> which actually means that everything written within a container to stdout or stderr is “picked up” by Docker Engine and is processed by the configured logging driver. This processing includes adding a lot of metadata about the container, swarm node, service etc. that’s specific to Docker. A sample message may look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
      "version":"1.1",
      "host":"swarm-manager-0",
      "short_message":"Starting HTTP service at 6868",
      "timestamp":1.487625824614e+09,
      "level":6,
      "_command":"./vipservice-linux-amd64 -profile=test",
      "_container_id":"894edfe2faed131d417eebf77306a0386b43027e0bdf75269e7f9dcca0ac5608",
      "_container_name":"vipservice.1.jgaludcy21iriskcu1fx9nx2p",
      "_created":"2017-02-20T21:23:38.877748337Z",
      "_image_id":"sha256:1df84e91e0931ec14c6fb4e559b5aca5afff7abd63f0dc8445a4e1dc9e31cfe1",
      "_image_name":"someprefix/vipservice:latest",
      "_tag":"894edfe2faed"
}
</code></pre></div></div>

<p>Let’s take a look at how to change our “docker service create” command in <em>copyall.sh</em> to use the GELF driver:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service create \
--log-driver=gelf \
--log-opt gelf-address=udp://192.168.99.100:12202 \
--log-opt gelf-compression-type=none \
--name=accountservice --replicas=1 --network=my_network -p=6767:6767 someprefix/accountservice
</code></pre></div></div>

<ul>
  <li>–log-driver=gelf tells Docker to use the <a href="https://docs.docker.com/engine/admin/logging/gelf/">gelf driver</a></li>
  <li>–log-opt gelf-address tells Docker where to send all log statements. In the case of gelf, we’ll use the UDP protocol and tell Docker to send log statements to a service on the defined IP:port. This service is typically something such as <a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-gelf.html">logstash</a> but in our case, we’ll build our own little log aggregation service in the next section.</li>
  <li>–log-opt gelf-compression-type tells Docker whether to use compression before sending the log statements. To keep things simple, no compression in this blog part.</li>
</ul>

<p>That’s more or less it! Any microservice instance created of the <em>accountservice</em> type will now send everything written to stdout/stderr to the configured endpoint. Do note that this means that we can’t use <em>docker logs [containerid]</em> command anymore to check the log of a given service since the (default) logging driver isn’t being used anymore.</p>

<p>We should add these gelf log driver configuration statements to all <em>docker service create</em> commands in our shell scripts, e.g. <a href="https://github.com/callistaenterprise/goblog/blob/P10/copyall.sh">copyall.sh</a>.</p>

<p>There’s one kludgy issue with this setup though - the use of a hard-coded IP-address to the Swarm Manager. Regrettably, even if we deploy our “gelftail” service as a Docker Swarm mode service, we can’t address it using its logical name when declaring a service. We can probably work around this drawback somehow using DNS or similar, feel free to enlighten us in the comments if you know how ;)</p>

<h3 id="using-gelf-with-logrus-hooks">Using GELF with Logrus hooks</h3>

<p>If you really need to make your logging more container-orchestrator agnostic, an option is to use the <a href="https://github.com/gemnasium/logrus-graylog-hook">gelf plugin</a> for Logrus to do GELF logging using hooks. In that setup, Logrus will format log statements to the GELF format by itself and can also be configured to transmit them to a UDP address just like when using the Docker GELF driver. However - by default Logrus has no notion about running in a containerized context so we’d basically have to figure out how to populate all that juicy metadata ourselves - perhaps using calls to the Docker Remote API or operating system functions.</p>

<p>I <em>strongly</em> recommend using the Docker GELF driver. Even though it ties your logging to Docker Swarm mode, other container orchestrators probably have similar support for collecting stdout/stderr logs from containers with forwarding to a central logging service.</p>

<h1 id="3-log-collection-and-aggregation-using-gelftail">3. Log collection and aggregation using “gelftail”</h1>
<p>That UDP server where all log statement are sent is often <em>Logstash</em> or similar, that provides powerful control over transformation, aggregation, filtering etc. of log statements before storing them in a backend such as Elasticsearch or pushing them to a LaaS.</p>

<p>However, Logstash isn’t exactly lightweight and in order to keep things simple (and fun!) we’re going to code our very own little “log aggregator”. I’m calling it “gelftail”. The name comes from the fact that once I had configured the Docker GELF driver for all my services, I had no way of seeing what was being logged anymore! I decided to write a simple UDP server that would pick up all data sent to it and dump to stdout, which then I could look at using <em>docker logs</em>. E.g. a stream of all log statements from all services. Not very practical but at least better than not seeing any logs at all.</p>

<p>The natural next step were then to attach this “gelftail” program to a LaaS backend, apply a bit of transformation, statement batching etc. which is exactly what we’re going to develop right away!</p>

<h2 id="gelftail">Gelftail</h2>

<p>In the root <em>/goblog</em> folder, create a new directory called <em>gelftail</em>. Follow the instructions below to create the requisite files and folders.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mdkir $GOPATH/src/github.com/callistaenterprise/goblog/gelftail
mdkir $GOPATH/src/github.com/callistaenterprise/goblog/gelftail/transformer
mdkir $GOPATH/src/github.com/callistaenterprise/goblog/gelftail/aggregator
cd $GOPATH/src/github.com/callistaenterprise/goblog/gelftail
touch gelftail.go
touch transformer/transform.go
touch aggregator/aggregator.go
</code></pre></div></div>

<p>Gelftail works along these lines:</p>

<ol>
  <li>Starting an UDP server (the one that the Docker GELF driver is sending log output to).</li>
  <li>For each UDP packet, we’ll assume it’s JSON-formatted output from logrus. We’ll do a bit of parsing to extract the actual <em>level</em> and <em>short_message</em> properties and <em>transform</em> the original log message slightly so it contains those properties as root-level elements.</li>
  <li>Next, we’ll use a buffered go channel as a logical “send queue” that our <em>aggregator</em> goroutine is reading from. For each received log message, it’ll check if it’s current <em>buffer</em> is &gt; 1 kb.</li>
  <li>If the buffer is large enough, it will do an HTTP POST to the <a href="https://www.loggly.com/">Loggly</a> http upload endpoint with the aggregated statements, clear the buffer and start building a new batch.</li>
</ol>

<p>Expressed using classic Enterprise Integration patterns (in a somewhat non-idiomatic way…) it looks like this:</p>

<p><img src="../../../../../../assets/blogg/goblog/part10-gelftail.png" alt="gelftail overview" /></p>

<h3 id="source-code-1">Source code</h3>
<p>The program will be split into three files. Start with <a href="https://github.com/callistaenterprise/goblog/blob/P10/gelftail/gelftail.go">gelftail.go</a> with a <em>main</em> package and some imports:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"net"
	"net/http"
	"os"
    "io/ioutil"
	"github.com/Sirupsen/logrus"
)
</code></pre></div></div>

<p>When registering with Loggly (our LaaS of choice for this blog series), we get an Authentication token that you must treat as a secret. Anyone having access to your token can at least send log statements into your account. So make sure you .gitignore <em>token.txt</em> or whatever name you pick for the file. Of course, one could use the configuration server from Part 7 and store the auth token as an encrypted property. For now, I’m keeping this as simple as possible so text file it is.</p>

<p>So let’s add a placeholder for our LaaS token and an <em>init()</em> function that tries to load this token from disk. If unsuccessful, we might as well log &amp; panic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var authToken = ""
var port *string

func init() {
	data, err := ioutil.ReadFile("token.txt")
    if err != nil {
        msg := "Cannot find token.txt that should contain our Loggly token"
        logrus.Errorln(msg)
        panic(msg)
    }
    authToken = string(data)
    
    port = flag.String("port", "12202", "UDP port for the gelftail")
    flag.Parse()
}
</code></pre></div></div>

<p>We also use a flag to take an optional port number for the UDP server. Next, time to declare our main() function to get things started.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func main() {
	logrus.Println("Starting Gelf-tail server...")

	ServerConn := startUDPServer(*port)   // Remember to dereference the pointer for our "port" flag
	defer ServerConn.Close()

	var bulkQueue = make(chan []byte, 1)  // Buffered channel to put log statements ready for LaaS upload into

	go aggregator.Start(bulkQueue, authToken)          // Start goroutine that'll collect and then upload batches of log statements
	go listenForLogStatements(ServerConn, bulkQueue)   // Start listening for UDP traffic

	logrus.Infoln("Started Gelf-tail server")
	
	wg := sync.WaitGroup{}
	wg.Add(1)
	wg.Wait()              // Block indefinitely
}    
</code></pre></div></div>

<p>Quite straightforward - start the UDP server, declare the channel we’re using to pass processed messages and start the “aggregator”. The <em>startUDPServer(*port)</em> function is not very interesting, so we’ll skip forward to <em>listenForLogStatements(..)</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func listenForLogStatements(ServerConn *net.UDPConn, bulkQueue chan[]byte) {
	buf := make([]byte, 8192)                        // Buffer to store UDP payload into. 8kb should be enough for everyone, right Bill? :D
	var item map[string]interface{}                  // Map to put unmarshalled GELF json log message into
	for {
            n, _, err := ServerConn.ReadFromUDP(buf)     // Blocks until data becomes available, which is put into the buffer.
            if err != nil {
                logrus.Errorf("Problem reading UDP message into buffer: %v\n", err.Error())
                continue                                 // Log and continue if there are problms
            }
            
            err = json.Unmarshal(buf[0:n], &amp;item)        // Try to unmarshal the GELF JSON log statement into the map
            if err != nil {                              // If unmarshalling fails, log and continue. (E.g. filter)
                logrus.Errorln("Problem unmarshalling log message into JSON: " + err.Error())
                item = nil
                continue
            }
            
            // Send the map into the transform function
            processedLogMessage, err := transformer.ProcessLogStatement(item)    
            if err != nil {
                logrus.Printf("Problem parsing message: %v", string(buf[0:n]))
            } else {
                bulkQueue &lt;- processedLogMessage          // If processing went well, send on channel to aggregator
            }
            item = nil
    }
}
</code></pre></div></div>

<p>Follow the comments in the code. The <a href="https://github.com/callistaenterprise/goblog/blob/P10/gelftail/transformer/transformer.go">transformer.go</a> file isn’t that exciting either, it just reads some stuff from one json property and transfers that onto the “root” GELF message. So let’s skip that.</p>

<p>Finally, a quite peek at the “aggregator” code in <em>/goblog/gelftail/aggregator/<a href="https://github.com/callistaenterprise/goblog/blob/P10/gelftail/aggregator/aggregator.go">aggregator.go</a></em> that processes the final log messages from the <em>bulkQueue</em> channel, aggregates and uploads to Loggly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var client = &amp;http.Client{}
var logglyBaseUrl = "https://logs-01.loggly.com/inputs/%s/tag/http/"
var url string

func Start(bulkQueue chan []byte, authToken string) {
        url = fmt.Sprintf(logglyBaseUrl, authToken) // Assemble the final loggly bulk upload URL using the authToken  
        buf := new(bytes.Buffer)
        for {
                msg := &lt;-bulkQueue                 // Blocks here until a message arrives on the channel.
                buf.Write(msg)
                buf.WriteString("\n")              // Loggly needs newline to separate log statements properly.

                size := buf.Len()
                if size &gt; 1024 {                   // If buffer has more than 1024 bytes of data...
                        sendBulk(*buf)  // Upload!
                        buf.Reset()
                }
        }
}
</code></pre></div></div>

<p>I just love the simplicity of Go code! Using a <em>bytes.Buffer</em>, we just enter an eternal loop where we block at <em>msg := &lt;-bulkQueue</em> until a message is received over the (unbuffered) channel. We write the content + a newline to the buffer and then check whether the buffer is larger than our pre-determined 1kb threshold. If so, we invoke the <em>sendBulk</em> func and clear the buffer. <em>sendBulk</em> just does a standard HTTP POST to loggly.</p>

<h3 id="build-dockerfile-deploy">Build, Dockerfile, Deploy</h3>

<p>Of course, we’ll deploy “gelftail” as a Docker Swarm mode <em>service</em> just as everything else. For that, we need a Dockerfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM iron/base

EXPOSE 12202/udp
ADD gelftail-linux-amd64 /
ADD token.txt /

ENTRYPOINT ["./gelftail-linux-amd64", "-port=12202"]
</code></pre></div></div>

<p><em>token.txt</em> is a simple text file with the Loggly authorization token, more on that in section 4. of this blog post.</p>

<p>Building and deploying should be straightforward. We’ll add a new .sh script to the root <em>/goblog</em> directory:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

export GOOS=linux
export CGO_ENABLED=0

cd gelftail;go get;go build -o gelftail-linux-amd64;echo built `pwd`;cd ..

export GOOS=darwin

docker build -t someprefix/gelftail gelftail/
docker service rm gelftail
docker service create --name=gelftail -p=12202:12202/udp --replicas=1 --network=my_network someprefix/gelftail
</code></pre></div></div>

<p>This should run in a few seconds. Verify that gelftail was successfully started by tailing its very own stdout log. Find it’s container id using <em>docker ps</em> and then check the log using <em>docker logs</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker logs -f e69dff960cec
time="2017-08-01T20:33:00Z" level=info msg="Starting Gelf-tail server..." 
time="2017-08-01T20:33:00Z" level=info msg="Started Gelf-tail server" 
</code></pre></div></div>

<p>If you do something with another service that logs stuff, the log output from that service should now appear in the tail above. Let’s scale the <em>accountservice</em> to two instances:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service scale accountservice=2
</code></pre></div></div>

<p>The tailed <em>docker logs</em> above should now output some stuff such as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time="2017-08-01T20:36:08Z" level=info msg="Starting accountservice" 
time="2017-08-01T20:36:08Z" level=info msg="Loading config from http://configserver:8888/accountservice/test/P10\n" 
time="2017-08-01T20:36:08Z" level=info msg="Getting config from http://configserver:8888/accountservice/test/P10\n" 
</code></pre></div></div>

<p>That’s all for “gelftail”. Let’s finish this blog post by taking a quick peek at “Loggly”.</p>

<h1 id="4-loggly">4. Loggly</h1>

<p>There are numerous “Logging as a Service” providers out there and I basically picked one (i.e. Loggly) that seemed to have a free tier suitable for demoing purposes, a nice GUI and a rich set of options for getting your log statements uploaded.</p>

<p><img src="../../../../../../assets/blogg/goblog/part10-loggly1.png" alt="loggly UI" /></p>

<p>There is a <a href="https://www.loggly.com/docs/logging-setup/">plethora</a> (see the list on the left in the linked page) of alternatives on how to get your logs into Loggly. I decided to use the <a href="https://www.loggly.com/docs/http-endpoint/">HTTP/S event API</a> that allows us to send multiple log statements in small batches by newline separation.</p>

<h3 id="getting-started">Getting started</h3>
<p>I suggest following their <a href="https://www.loggly.com/docs/logging-setup/">getting started</a> guide, which can be boiled down to:</p>

<ol>
  <li>Create an account. (Free tier works well for demoing / trying out purposes)</li>
  <li>Obtain an authorization token. Save this somewhere safe and copy-paste it into <em>/goblog/gelftail/token.txt</em>.</li>
  <li>Decide how to “upload” your logs. As stated above, I chose to go with the HTTP/S POST API.</li>
  <li>Configure your services/logging driver/logstash/gelftail etc. to use your upload mode of choice.</li>
</ol>

<p>Leveraging all the bells &amp; whistles of Loggly is out of scope for this blog post. I’ve only tinkered around with their dashboard and filtering functions which I guess is pretty standard as LaaS providers go.</p>

<h3 id="a-few-examples">A few examples</h3>

<p>In the first screenshot, I’ve zoomed in on a 35-minute time duration where I’m explicitly filtering on the “accountservice” and “info” messages:</p>

<p><img src="../../../../../../assets/blogg/goblog/part10-loggly2.png" alt="loggly 2" /></p>

<p>As seen, one can customize columns, filter values, time periods etc. very easily.</p>

<p>In the next sample, I’m looking at the same time period, but only at “error” log statements:</p>

<p><img src="../../../../../../assets/blogg/goblog/part10-loggly3.png" alt="loggly 3" /></p>

<p>While these sample use cases are very simple, the real usefulness materializes when you’ve got dozens of microservices each running 1-n number of instances. That’s when the powerful indexing, filtering and other functions of your LaaS really becomes a fundamental part of your microservices operations model.</p>

<h1 id="summary">Summary</h1>
<p>In part 10 of the <a href="../../../02/17/go-blog-series-part1.html">blog series</a> we’ve looked at centralized logging - why it’s important, how to do structured logging in your Go services, how to use a logging driver from your container orchestrator and finally pre-processing log statments before uploading them to a Logging as a Service provider.</p>

<p>In the <a href="../../../09/11/go-blog-series-part11.html">next part</a>, it’s time to add circuit breakers and resilience to our microservices using Netflix Hystrix.</p>









            <div class="ce-blog-thanks">
              Tack för att du läser Callistas blogg. <br>
              Hjälp oss att nå ut med information genom att dela nyheter och artiklar i ditt nätverk.<br>
            </div>

            


    
<div class="ce-blog-share">
    <a class="ce-blog-share-element social-twitter" href="https://twitter.com/intent/tweet?text=Go Blog Series Part10&url=https://callistaenterprise.se/blogg/teknik/2017/08/02/go-blog-series-part10/&via=callistaent&hashtags=" target="_blank" title="Share this post on Twitter"></a>
    <a class="ce-blog-share-element social-facebook" href="https://www.facebook.com/sharer/sharer.php?t=Go Blog Series Part10&u=https://callistaenterprise.se/blogg/teknik/2017/08/02/go-blog-series-part10/" target="_blank" title="Share this post on Facebook"></a>
    <a class="ce-blog-share-element social-linkedin" href="http://www.linkedin.com/shareArticle?mini=true&title=Go Blog Series Part10&url=https://callistaenterprise.se/blogg/teknik/2017/08/02/go-blog-series-part10/&source=http%3a%2f%2fzhangwenli.com" target="_blank" title="Share this post on LinkedIn"></a>
</div>
    
        </article>
    </div>
</section>


<section class="ce-section">
    <heading>
        <h1>Kommentarer</h1>
    </heading>
    <div class="ce-content">
        <div id="disqus_thread"></div>
        <script src="../../../../../../js/disqus.js"></script>
    </div>
</section>


    </div>

    <footer class="ce-footer">
    <div class="ce-wrapper">
        <nav class="ce-menu-footer-primary">
            <h2><a href="../../../../../../index.html">Callista</a></h2>
            <ul>
                
                <li><a href="../../../../../../om/index.html">Om oss</a></li>
                
                <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                
                <li><a href="../../../../../../event.html">Event</a></li>
                
                <li><a href="../../../../../../blogg.html">Blogg</a></li>
                
                <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                

                
                    
                        <li><a href="../../../../../../english/index.html">English</a></li>
                    
                
            </ul>
        </nav>
        <div class="ce-addresses">
            <div class="ce-address">
                <h2>Stockholm</h2>
                <address>
                    Drottninggatan 55<br>
                    111 21 Stockholm<br>
                    Tel:
                    <a href="tel:+468212142">
                        +46 8 21 21 42
                    </a>
                </address>
            </div>
            <div class="ce-address">
                <h2>Göteborg</h2>
                <address>
                    Fabriksgatan 13<br>
                    412 50 Göteborg<br>
                    Tel:
                    <a href="tel:+4631201918">
                        +46 31 20 19 18
                    </a>
                </address>
            </div>
        </div>
        <div class="ce-social">
            <h2>Följ oss</h2>
            <ul>
                <li>
                    <a href="http://twitter.com/callistaent">
                        <img alt="Twitters logotype" src="../../../../../../images/icons/twitter.png">
                        <span>@callistaent</span>
                    </a>
                </li>
            </ul>
        </div>
        <small>&copy; 2021 Callista Enterprise AB</small>
        <hr style="margin: 1em 0 2em 0">
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-raddabarnen" href="http://www.raddabarnen.se/foretag">
                <img alt="Callista är Rädda Barnens företagsvän 2021" src="../../../../../../images/logotype/rb_vanforetag_2021_large-sv.png">
            </a>
          </div>
        </div>
        <br>
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-di-gasell" href="http://www.di.se/gasell/">
              <img alt="Callista utsett till DI Gasell tre år i rad" src="../../../../../../images/logotype/di_gasell_180x194.png">
            </a>
          </div>
        </div>
    </div>
</footer>


    <script src="../../../../../../js/lib/jquery.min.js"></script>
    <script src="../../../../../../js/lib/owl.carousel.min.js"></script>
    <script src="../../../../../../js/lib/prismjs.min.js"></script>
    <script src="../../../../../../js/app.js"></script>
    <script src="../../../../../../js/analytics.js"></script>
    <script src="../../../../../../js/jobinterestsubmit.js"></script>

</body>
</html>
