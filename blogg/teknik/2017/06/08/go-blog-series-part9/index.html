<!DOCTYPE html>
<html lang="sv-se">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Callista Enterprise - seniora IT-arkitekter och systemutvecklare inom Java, öppen källkod, agil utveckling och systemintegration">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
    <meta name="viewport" content="initial-scale=1.0001, minimum-scale=1.0001, maximum-scale=1.0001, user-scalable=no"/>

    <link rel="icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="shortcut icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="apple-touch-icon" href="../../../../../../images/icons/callista_favicon_160x160.png">

    <title>Go Microservices blog series, part 9 - Messaging with RabbitMQ and AMQP | Callista</title>

    <link rel="stylesheet" href="../../../../../../css/style.css%3Fv=1.css">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for callistaenterprise.se" href="../../../../../../feed.xml" />

    <!--[if lte IE 8]>
    <style>* { display: none !important; }</style>
    <meta http-equiv="refresh" content="0; url=/oldie/"/>
    <![endif]-->

    <script type="text/javascript" src="https://use.typekit.net/kig5egm.js"></script>
    <script type="text/javascript">
        try {
            Typekit.load({ async: true });
        } catch (e) {
        }
    </script>

    <!-- Facebook Pixel Code -->
    <script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window,document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
     fbq('init', '804675599711872');
     fbq('track', 'PageView');
    </script>
    <noscript>
     <img height="1" width="1" src="https://www.facebook.com/tr?id=804675599711872&ev=PageView&noscript=1"/>
    </noscript>
    <!-- End Facebook Pixel Code -->

</head>
<body>

    <header class="ce-header" data-scroll="0">
    <nav>
        <img alt="menubg" class="ce-menu-icon" style="z-index:3; top: 0px; width: 50px; height: 100%;" src="../../../../../../images/icons/menu_background.png">
        <a class="ce-logotype" href="../../../../../../index.html" style="z-index: 2;">
            <img alt="Callista" style="max-width: 100%; height: auto;" src="../../../../../../images/logotype/callista_small2.svg">
        </a>
        <table>
            <tr>
                <td>
            <ul id="menu-primary" class="ce-menu-primary">
                
                    
                            <li><a href="../../../../../../om/index.html">Om oss</a></li>
                    
                
                    
                            <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                    
                
                    
                            <li><a href="../../../../../../event.html">Event</a></li>
                    
                
                    
                        
                            <li><a class="ce-active" href="../../../../../../blogg.html">Blogg</a></li>
                        
                    
                
                    
                            <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                    
                
            </ul>
                </td>

                <td>
            <ul class="ce-menu-secondary">
                
                <li><a href="../../../../../../english/index.html">English</a></li>
                
            </ul>
                </td>
            </tr>
        </table>
            <a id="menu" class="ce-menu-icon" href="../go-blog-series-part9.html#" style="z-index: 4;">
                <img alt="Visa meny" src="../../../../../../images/icons/menu.png">
            </a>
            <a class="ce-search-icon" href="../go-blog-series-part9.html#">
                <img alt="Sök" src="../../../../../../images/icons/search.png">
            </a>

        </table>
    </nav>
</header>


    <div class="ce-main">
        <section class="ce-start lazyImg">
    <article>
        <h1>Blogg</h1>
        <p class="ce-ingress">
            Här finns tekniska artiklar, presentationer och nyheter om arkitektur och systemutveckling. Håll dig uppdaterad, följ oss på <a class="ce-active" href="http://twitter.com/callistaent">Twitter</a>
        </p>
    </article>
</section>

<section class="ce-section">
    <div class="ce-content">
        
        

        
        

        <article class="ce-blog">
            <header>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <img alt="Callista medarbetare Erik Lupander" src="../../../../../../assets/medarbetare/eriklupander_mini.png">
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <h2>
        <a href="../go-blog-series-part9.html">Go Microservices blog series, part 9 - Messaging with RabbitMQ and AMQP</a>
        
        
    </h2>
    <h3>
        <time datetime="2017-06-08T00:00:00+00:00">
            08 June 2017
        </time>
        //
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        <a href="../../../../../../om/medarbetare/eriklupander/index.html">Erik Lupander</a>
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </h3>
    
</header>




<p>In part 9 of the Go microservices <a href="../../../02/17/go-blog-series-part1.html">blog series</a>, we’ll examine messaging between Go microservices using RabbitMQ and the AMQP protocol.</p>

<h1 id="introduction">Introduction</h1>
<p>Microservices is all about separating your application’s business domain into bounded contexts with clearly separated domains, running with process separation where any persistent relations across domain boundaries has to rely on eventual consistency rather than ACID-like transactions or foreign key constraints. A lot of these concepts comes from or has been inspired by <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain-driven design</a> (DDD). That’s yet another huge topic one could write a blog series about.</p>

<p>In the context of our Go microservice <a href="../../../02/17/go-blog-series-part1.html">blog series</a> and microservice architecture in general, one pattern for accomplishing loose coupling between services is to use messaging for inter-service communication that doesn’t need a strict request/response message interchange or similar. That said, using messaging is just one of many strategies one can adopt to facilitate loose coupling between services.</p>

<p>In Spring Cloud, RabbitMQ seems to be the message broker of choice, especially since the Spring Cloud Config server has RabbitMQ as a runtime dependency as we saw in <a href="../../../05/15/go-blog-series-part8.html">part 8</a> of the blog series.</p>

<p>For this part of the blog series, we’ll make our “accountservice” place a message on a RabbitMQ <em>Exchange</em> whenever a particular account object has been read. This message will be consumed by a brand new microservice we’ll write in this blog post. We’ll also deal with reusing Go code across multiple microservices by putting them in a “common” library we can import into each service.</p>

<p>Remember the system landscape image from Part 1? Here’s an image of what it’ll look like after this part has been finished:</p>

<p><img src="../../../../../../assets/blogg/goblog/part9-overview.png" alt="part9 overview" /></p>

<p>There’s still a <em>lot</em> of stuff missing until we’re done. Don’t worry, we’ll get there.</p>

<h1 id="source-code">Source code</h1>
<p>There will be a lot of new source code for this part and not all of it will be included in the blog text. For the complete source, clone and switch to the branch for part 9:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout P9
</code></pre></div></div>

<p><em>Note: Most of the Go source code for the blog series was rewritten in July 2019 to better reflect contemporary idiomatic Go coding guidelines and design patterns. However, the corresponding <a href="https://github.com/callistaenterprise/goblog/tree/P9">git branch</a> for each part of the series remains unchanged in order to stay aligned with the content of each installment. For the latest and greatest code, look at the <a href="https://github.com/callistaenterprise/goblog">master</a> branch in github.</em></p>

<h1 id="sending-a-message">Sending a message</h1>
<p>We’ll implement a simple make-believe use case: When certain “VIP” accounts are read in the “accountservice”, we want to notify an “VIP offer” service that under certain circumstances will generate an “offer” for the account holder. In a properly designed domain model, the accounts objects and VIP offer objects are two independent domains that should have as little knowledge of each other as possible.</p>

<p><img src="../../../../../../assets/blogg/goblog/part9-separation.png" alt="separation" /></p>

<p>I.e - the accountservice should <strong>never</strong> access the storage of the VIP service (offers) directly. In this case, we’re passing a message to the “vipservice” over RabbitMQ fully delegating both business logic and persistence to the “vipservice”.</p>

<p>We’ll do all communication using the <a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">AMQP</a> protocol which is a ISO standardized application layer protocol for messaging geared for interoperability. Our Go library of choice for using AMQP is <a href="https://github.com/streadway/amqp">streadway/amqp</a>, just like in part 8 when we consumed configuration updates.</p>

<p>Let’s repeat how <em>exchanges</em> in AMQP relates to <em>publishers</em>, <em>consumers</em> and <em>queues</em>:</p>

<p><img src="../../../../../../assets/blogg/goblog/part9-rabbitmq-exchange.png" alt="amqp" /></p>

<p>I.e - a message is published to an <em>exchange</em>, which then distributes message copies to <em>queue(s)</em> based on <em>routing</em> rules and bindings which may have registered <em>consumers</em>. Check <a href="https://www.quora.com/Why-does-RabbitMQ-have-both-exchanges-and-queues">this thread</a> on Quora for a good explanation.</p>

<h2 id="messaging-code">Messaging code</h2>
<p>Since we’ll want to use our new messaging code as well as our existing code for loading configuration from Spring Cloud config in both our existing <em>accountservice</em> and the new <em>vipservice</em>, we’ll create our first shared library.</p>

<p>Start by creating new folders under <em>/goblog/</em> called <em>common</em> to keep our new reusable stuff:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mkdir -p common/messaging
&gt; mkdir -p common/config
</code></pre></div></div>

<p>We’ll put all AMQP-related code in the <em>messaging</em> folder and the configuration stuff in the <em>config</em> folder. You can copy the contents of <em>/goblog/accountservice/config</em> into <em>/goblog/common/config</em> - remember that this will require us to update the <em>import</em> statements previously importing our config code from within the <em>accountservice</em>. Just take a look at the <a href="https://github.com/callistaenterprise/goblog/tree/P9/common">finished source</a> to see how it’s supposed to be.</p>

<p>The messaging code will be encapsulated in a single file that will define both the interface our applications will use to connect, publish and subscribe as well as the actual implementation. In all honesty, there is a lot of boilerplate code required for AMQP-messaging using streadway/amqp so don’t get bogged down in the details.</p>

<p>Create a new .go file in <em>/goblog/common/messaging</em>: <a href="https://github.com/callistaenterprise/goblog/blob/P9/common/messaging/messagingclient.go">messagingclient.go</a></p>

<p>Let’s have a look at the important stuff</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Defines our interface for connecting, producing and consuming messages.
type IMessagingClient interface {
        ConnectToBroker(connectionString string)
        Publish(msg []byte, exchangeName string, exchangeType string) error
        PublishOnQueue(msg []byte, queueName string) error
        Subscribe(exchangeName string, exchangeType string, consumerName string, handlerFunc func(amqp.Delivery)) error
        SubscribeToQueue(queueName string, consumerName string, handlerFunc func(amqp.Delivery)) error
        Close()
}
</code></pre></div></div>

<p>The snippet above defines our messaging interface. This is what our “accountservice” and “vipservice” will deal with when it comes to messaging, hopefully abstracting away most complexity. Note that I’ve chosen two variants of “Produce” and “Consume” to use with <em>topics</em> and <em>direct/queue</em> messaging patterns.</p>

<p>Next, we’ll define a struct which will hold a pointer to an amqp.Connection and that we will attach the requisite methods to so it (implicitly, as always with Go) implements the interface we just declared.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Real implementation, encapsulates a pointer to an amqp.Connection
type MessagingClient struct {
        conn *amqp.Connection
}
</code></pre></div></div>

<p>The implementations are quite verbose so let’s limit ourselves to two of them - <em>ConnectToBroker()</em> and <em>PublishToQueue()</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (m *MessagingClient) ConnectToBroker(connectionString string) {
        if connectionString == "" {
                panic("Cannot initialize connection to broker, connectionString not set. Have you initialized?")
        }

        var err error
        m.conn, err = amqp.Dial(fmt.Sprintf("%s/", connectionString))
        if err != nil {
                panic("Failed to connect to AMQP compatible broker at: " + connectionString)
        }
}
</code></pre></div></div>

<p>This is how we get hold of the connection pointer, e.g. <em>amqp.Dial</em>. If we’re missing our config or cannot contact our broker, we’ll panic our microservice and let the container orchestrator try again with a fresh instance. The passed connection string looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>amqp://guest:guest@rabbitmq:5672/
</code></pre></div></div>

<p>Note that we’re using the Docker Swarm mode <em>service</em> name of the rabbitmq broker.</p>

<p>The <em>PublishOnQueue()</em> function is quite long - it’s more or less derived from the official <a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html">streadway samples</a>, though I’ve simplified it a bit with fewer parameters. To publish a message to a named queue, all we need to pass is:</p>

<ul>
  <li>body in the form of a byte array. Could be JSON, XML or some binary.</li>
  <li>queueName - name of the queue you want to send your message to.</li>
</ul>

<p>For more details about exchanges, see the <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">RabbitMQ docs</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (m *MessagingClient) PublishOnQueue(body []byte, queueName string) error {
        if m.conn == nil {
                panic("Tried to send message before connection was initialized. Don't do that.")
        }
        ch, err := m.conn.Channel()      // Get a channel from the connection
        defer ch.Close()

        // Declare a queue that will be created if not exists with some args
        queue, err := ch.QueueDeclare(
                queueName, // our queue name
                false, // durable
                false, // delete when unused
                false, // exclusive
                false, // no-wait
                nil, // arguments
        )

        // Publishes a message onto the queue.
        err = ch.Publish(
                "", // use the default exchange
                queue.Name, // routing key, e.g. our queue name
                false, // mandatory
                false, // immediate
                amqp.Publishing{
                        ContentType: "application/json",
                        Body:        body, // Our JSON body as []byte
                })
        fmt.Printf("A message was sent to queue %v: %v", queueName, body)
        return err
}
</code></pre></div></div>

<p>A bit heavy on the boilerplate, but should be easy enough to understand. Declare the queue (so it’s created if it does not exist) and then publish our <em>[]byte</em> message to it. The code that publishes a message to a named exchange is more complex as it requires boilerplate to first declare an exchange, a queue and then code to <em>bind</em> them together. See the <a href="https://github.com/callistaenterprise/goblog/blob/P9/common/messaging/messagingclient.go#L38">complete source</a> for an example.</p>

<p>Moving on, the actual user of our “MessageClient” will be <em>/goblog/accountservice/service/handlers.go</em>, so we’ll add a field for that and the hard-coded “is VIP” check that will send a message if the requested account was has id “10000”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var DBClient dbclient.IBoltClient
var MessagingClient messaging.IMessagingClient     // NEW

func GetAccount(w http.ResponseWriter, r *http.Request) {
     ...
</code></pre></div></div>

<p>a bit further down</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ...
    notifyVIP(account)   // Send VIP notification concurrently.

    // If found, marshal into JSON, write headers and content
	data, _ := json.Marshal(account)
    writeJsonResponse(w, http.StatusOK, data)
}

// If our hard-coded "VIP" account, spawn a goroutine to send a message.
func notifyVIP(account model.Account) {
        if account.Id == "10000" {
                go func(account model.Account) {
                        vipNotification := model.VipNotification{AccountId: account.Id, ReadAt: time.Now().UTC().String()}
                        data, _ := json.Marshal(vipNotification)
                        err := MessagingClient.PublishOnQueue(data, "vipQueue")
                        if err != nil {
                                fmt.Println(err.Error())
                        }
                }(account)
        }
}
</code></pre></div></div>

<p>Taking the opportunity to showcase an inlined anonymous function that we’re calling on a new goroutine, i.e. using the <em>go</em> keyword. Since we have no reason whatsoever to block the “main” goroutine that’s executing the HTTP handler while sending a message, this is a perfect time to add a bit of concurrency.</p>

<p><em>main.go</em> also needs to be updated so it initializes the AMQ connection on startup using configuration loaded and injected into Viper.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Call this from the main method.
func initializeMessaging() {
	if !viper.IsSet("amqp_server_url") {
		panic("No 'amqp_server_url' set in configuration, cannot start")
	}

	service.MessagingClient = &amp;messaging.MessagingClient{}
	service.MessagingClient.ConnectToBroker(viper.GetString("amqp_server_url"))
	service.MessagingClient.Subscribe(viper.GetString("config_event_bus"), "topic", appName, config.HandleRefreshEvent)
}
</code></pre></div></div>

<p>No big deal - we’re assigning the <em>service.MessagingClient</em> instance by creating an empty messaging struct and the calling ConnectToBroker using a property value fetched from Viper. If our configuration doesn’t contain a <em>broker_url</em>, we panic as we don’t want to be running without even the possibility to connect to the broker.</p>

<h2 id="updating-configuration">Updating configuration</h2>
<p>We added the <em>amqp_broker_url</em> property to our .yml config files back in part 8, so that’s already been taken care of.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>broker_url: amqp://guest:guest@192.168.99.100:5672 _(dev)_   

broker_url: amqp://guest:guest@rabbitmq:5672 _(test)_
</code></pre></div></div>

<p>Note that for the “test” profile, we’re using the Swarm Service name “rabbitmq” instead of the LAN IP address of the Swarm as seen from my dev laptop. (Your actual IP address may vary, 192.168.99.100 seems to be standard when running Docker Toolbox).</p>

<p>As for having clear-text usernames and passwords in configuration files that’s not recommended, in a real-life scenario one could typically use the built-in encryption feature of the Spring Cloud Config server we looked at in Part 8.</p>

<h2 id="unit-testing">Unit testing</h2>
<p>Naturally, we should at least write a unit test that makes sure our <em>GetAccount</em> function in <em>handlers.go</em> does try to send a message whenever someone requests the magical and very very special account identified by “10000”.</p>

<p>For this - we need a mock implementation of the IMessagingClient and a new test case in <em>handlers_test.go</em>. Let’s start with the mock. This time we’ll use the 3rd party tool <a href="https://github.com/vektra/mockery">mockery</a> to generate a mock implementation of our IMessagingClient interface:
<em>(remember to run these commands in a shell with a proper GOPATH set)</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; go get github.com/vektra/mockery/.../
&gt; cd $GOPATH/src/github.com/callistaenterprise/goblog/common/messaging 
&gt; ./$GOPATH/bin/mockery -all -output .
  Generating mock for: IMessagingClient
</code></pre></div></div>

<p>Now we have a mock file <em>IMessagingClient.go</em> in our current folder. I don’t like the name of the file nor the camelcasing, so we’ll rename it to something that makes it evident that it’s a mock and follows the conventions for file names used in the blog series:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> mv IMessagingClient.go mockmessagingclient.go
</code></pre></div></div>

<p>It’s possible you’ll need to adjust the imports somewhat in the generated file, removing the import aliases. Other than that, we’ll use a black-box approach to this particular mock - just assume it’ll work when we start writing tests.</p>

<p>Feel free to examine the <a href="https://github.com/callistaenterprise/goblog/blob/P9/common/messaging/mockmessagingclient.go">source</a> of the generated mock implementation, it’s very similar to the stuff we hand-coded back in <a href="../../../03/03/go-blog-series-part4.html">part 4</a> of the blog series.</p>

<p>Moving on to <em>handlers_test.go</em> we’re adding a new test case:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// declare mock types to make test code a bit more readable
var anyString = mock.AnythingOfType("string")
var anyByteArray = mock.AnythingOfType("[]uint8")  // == []byte


func TestNotificationIsSentForVIPAccount(t *testing.T) {
        // Set up the DB client mock
        mockRepo.On("QueryAccount", "10000").Return(model.Account{Id:"10000", Name:"Person_10000"}, nil)
        DBClient = mockRepo

        mockMessagingClient.On("PublishOnQueue", anyByteArray, anyString).Return(nil)
        MessagingClient = mockMessagingClient

        Convey("Given a HTTP req for a VIP account", t, func() {
                req := httptest.NewRequest("GET", "/accounts/10000", nil)
                resp := httptest.NewRecorder()
                Convey("When the request is handled by the Router", func() {
                        NewRouter().ServeHTTP(resp, req)
                        Convey("Then the response should be a 200 and the MessageClient should have been invoked", func() {
                                So(resp.Code, ShouldEqual, 200)
                                time.Sleep(time.Millisecond * 10)    // Sleep since the Assert below occurs in goroutine
                                So(mockMessagingClient.AssertNumberOfCalls(t, "PublishOnQueue", 1), ShouldBeTrue)
                        })
        })})
}
</code></pre></div></div>

<p>For details, follow the comments. I don’t like that artificial 10 ms sleep just before asserting numberOfCalls, but since the mock is called in a goroutine separate from the “main thread” we need to allow it a tiny bit of time to complete. Hope there’s a better idiomatic way of unit-testing when there’s goroutines and channels involved.</p>

<p>I admit - mocking this way is more verbose than using something like Mockito when writing unit-tests for a Java application. Still, I think it’s quite readable and easy enough to write.</p>

<p>Make sure that the test passes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go test ./...
</code></pre></div></div>

<h2 id="running">Running</h2>
<p>If you havn’t, run the the <em>springcloud.sh</em> script to update the config server. Then, run <em>copyall.sh</em> and wait a few seconds while our “accountservice” is updated. We’ll use curl to fetch our “special” account.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; curl http://$ManagerIP:6767/accounts/10000
{"id":"10000","name":"Person_0","servedBy":"10.255.0.11"}
</code></pre></div></div>

<p>If things went well, we should be able to open the RabbitMQ admin console and see if we’ve gotten a message on a queue named <em>vipQueue</em>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open http://192.168.99.100:15672/#/queues
</code></pre></div></div>

<p><img src="../../../../../../assets/blogg/goblog/part9-rabbitmq.png" alt="rabbitmq with 1 message in queue" /></p>

<p>At the very bottom of the screenshot above, we see that the “vipQueue” has 1 message. If we use the “Get Message” function within the RabbitMQ admin console, we can look at this message:</p>

<p><img src="../../../../../../assets/blogg/goblog/part9-rabbitmq2.png" alt="the message" /></p>

<h1 id="writing-a-consumer-in-go---the-vipservice">Writing a consumer in Go - the “Vipservice”</h1>
<p>Finally, it’s time to write a brand new microservice from scratch that we’ll use to showcase how to consume a message from RabbitMQ. We’ll make sure to apply the patterns we’ve learned in the blog series up until now, including:</p>

<ul>
  <li>HTTP server</li>
  <li>Health check</li>
  <li>Centralized configuration</li>
  <li>Reuse of messaging code</li>
</ul>

<p>If you’ve checked out the P9 source you can already see the “vipservice” in the root <em>/goblog</em> folder.</p>

<p>I won’t go through every single line of code here as some parts are repeated from the “accountservice”. Instead we’ll focus on the consuming the message we just sent. A few things to note:</p>

<ul>
  <li>Two new .yml files added to the config-repo, <em>vipservice-dev.yml</em> and <em>vipservice-test.yml</em></li>
  <li><em>copyall.sh</em> has been updated so it builds and deploys both the “accountservice” and our new “vipservice”.</li>
</ul>

<h2 id="consuming-a-message">Consuming a message</h2>
<p>We’ll use the code from <em>/goblog/common/messaging</em> and the <em>SubscribeToQueue</em> function, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SubscribeToQueue(queueName string, consumerName string, handlerFunc func(amqp.Delivery)) error
</code></pre></div></div>

<p>Of most note here is the that we’re supposed to provide:</p>

<ul>
  <li>the name of the queue (e.g. “vip_queue”)</li>
  <li>a consumer name (who we are)</li>
  <li>a handler function that will be invoked with a received delivery - very similar to what we did when consuming config updates in part 8.</li>
</ul>

<p>The implementation of <em>SubscribeToQueue</em> that actually binds our callback function to a queue isn’t that exciting, check the <a href="https://github.com/callistaenterprise/goblog/blob/P9/common/messaging/messagingclient.go#L170">source</a> if you want the details.</p>

<p>Moving on, a quick peek at an excerpt of the vipservice’s <em>main.go</em> shows how we’re setting things up:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var messagingClient messaging.IMessagingConsumer

func main() {
	fmt.Println("Starting " + appName + "...")

	config.LoadConfigurationFromBranch(viper.GetString("configServerUrl"), appName, viper.GetString("profile"), viper.GetString("configBranch"))
	initializeMessaging()

	// Makes sure connection is closed when service exits.
	handleSigterm(func() {
		if messagingClient != nil {
			messagingClient.Close()
		}
	})
	service.StartWebServer(viper.GetString("server_port"))
}

// The callback function that's invoked whenever we get a message on the "vipQueue"
func onMessage(delivery amqp.Delivery) {
	fmt.Printf("Got a message: %v\n", string(delivery.Body))
}

func initializeMessaging() {
        if !viper.IsSet("amqp_server_url") {
            panic("No 'broker_url' set in configuration, cannot start")
        }
        messagingClient = &amp;messaging.MessagingClient{}
        messagingClient.ConnectToBroker(viper.GetString("amqp_server_url"))
        
        // Call the subscribe method with queue name and callback function
        err := messagingClient.SubscribeToQueue("vip_queue", appName, onMessage)
        failOnError(err, "Could not start subscribe to vip_queue")

        err = messagingClient.Subscribe(viper.GetString("config_event_bus"), "topic", appName, config.HandleRefreshEvent)
        failOnError(err, "Could not start subscribe to " + viper.GetString("config_event_bus") + " topic")
}
</code></pre></div></div>

<p>Looks familiar, right? We’ll probably repeat the basics of how to setup and boot each microservice we add.</p>

<p>The <em>onMessage</em> function just logs the body of whatever “vip” message we receive. If we would implement more of our make-believe use case it would have invoked some fancy logic to determine if the account holder was eligible for the <em>“super-awesome buy all our stuff (tm)”</em> offer and possible write an offer to the “VIP offer database”. Feel free to implement and submit a pull request ;)</p>

<p>Not much to add. Except this snippet that allows us to clean up whenever we press Ctrl+C or when Docker Swarm thinks it’s time to kill a service instance:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   func handleSigterm(handleExit func()) {
           c := make(chan os.Signal, 1)
           signal.Notify(c, os.Interrupt)
           signal.Notify(c, syscall.SIGTERM)
           go func() {
                   &lt;-c
                   handleExit()
                   os.Exit(1)
           }()
   }
</code></pre></div></div>

<p>Not the most readable piece of code, what is does is that it registers the channel “c” as listener for os.Interrupt and syscall.SIGTERM and a goroutine that will block listening for message on “c” until either of the signals are received. This allows us to be pretty sure that the <em>handleExit()</em> function we supplied will be invoked whenever the microservice is being killed. How sure? Ctrl+C or docker swarm scaling works fine. <em>kill</em> does too. <em>kill -9</em> doesn’t. So please don’t stop stuff using <em>kill -9</em> unless you have to.</p>

<p>It will call that <em>Close()</em> func we declared on the IMessageConsumer interface, which in the implementation makes sure the AMQP conn is properly closed.</p>

<h1 id="deploy-and-run">Deploy and run</h1>
<p>The <em><a href="https://github.com/callistaenterprise/goblog/blob/P9/copyall.sh">copyall.sh</a></em> script has been updated, so if you’re following along make sure it’s up-to date with branch P9 on github and run it. When everything’s done, <em>docker service ls</em> should print something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service ls
ID            NAME            REPLICAS  IMAGE                        
kpb1j3mus3tn  accountservice  1/1       someprefix/accountservice                                                                            
n9xr7wm86do1  configserver    1/1       someprefix/configserver                                                                              
r6bhneq2u89c  rabbitmq        1/1       someprefix/rabbitmq                                                                                  
sy4t9cbf4upl  vipservice      1/1       someprefix/vipservice                                                                                
u1qcvxm2iqlr  viz             1/1       manomarks/visualizer:latest
</code></pre></div></div>

<p>(or using the <a href="https://github.com/eriklupander/dvizz">dvizz</a> Docker Swarm services renderer):</p>

<p><img src="../../../../../../assets/blogg/goblog/part9-dvizz.png" alt="dvizz" /></p>

<h3 id="checking-logs">Checking logs</h3>
<p>Since the <em>docker service logs</em> feature is marked as experimental in 1.13.0, we have to look at the “vipservice” logs the old-school way. First, run <em>docker ps</em> to figure out the container id:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker ps
CONTAINER ID        IMAGE                                                                                       
a39e6eca83b3        someprefix/vipservice:latest           
b66584ae73ba        someprefix/accountservice:latest        
d0074e1553c7        someprefix/configserver:latest       
</code></pre></div></div>

<p>Pick the CONTAINER ID for the vipservice and check its logs using <em>docker logs -f</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker logs -f a39e6eca83b3
Starting vipservice...
2017/06/06 19:27:22 Declaring Queue ()
2017/06/06 19:27:22 declared Exchange, declaring Queue ()
2017/06/06 19:27:22 declared Queue (0 messages, 0 consumers), binding to Exchange (key 'springCloudBus')
Starting HTTP service at 6868
</code></pre></div></div>

<p>Open another command shell and curl our special Account object.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; curl http://$ManagerIP:6767/accounts/10000
</code></pre></div></div>

<p>If everything works, we should see a message being consumed in the log of the original window.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Got a message: {"accountId":"10000","readAt":"2017-02-15 20:06:27.033757223 +0000 UTC"}
</code></pre></div></div>

<h1 id="work-queues">Work queues</h1>
<p>A pattern for distributing work across multiple instances of a service is to utilize the concept of <a href="https://www.rabbitmq.com/tutorials/tutorial-two-go.html">work queues</a>. Each “vip message” should be processed by a single “vipservice” instance.</p>

<p><img src="../../../../../../assets/blogg/goblog/part9-workqueue.png" alt="workqueue" /></p>

<p>So let’s see what happens when scale our “vipservice” to two instances using the <em>docker service scale</em> command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service scale vipservice=2
</code></pre></div></div>

<p>A new instance of “vipservice” should be available within a few seconds.</p>

<p>Since we’re using the <em>direct/queue</em> approach in AMQP we expect round-robin behaviour. Use <em>curl</em> to trigger four VIP account lookups:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; curl http://$ManagerIP:6767/accounts/10000
&gt; curl http://$ManagerIP:6767/accounts/10000
&gt; curl http://$ManagerIP:6767/accounts/10000
&gt; curl http://$ManagerIP:6767/accounts/10000
</code></pre></div></div>

<p>Check the log of our original “vipservice” again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker logs -f a39e6eca83b3
Got a message: {"accountId":"10000","readAt":"2017-02-15 20:06:27.033757223 +0000 UTC"}
Got a message: {"accountId":"10000","readAt":"2017-02-15 20:06:29.073682324 +0000 UTC"}
</code></pre></div></div>

<p>As expected, we see that the first instance processed two of the four expected messages. If we’d do <em>docker logs</em> for the other “vipservice” instance we’d see two messages there as well. Promise.</p>

<h2 id="testing-the-consumer">Testing the consumer</h2>
<p>Actually - I havn’t really come up with an attractive way to unit test the AMQP consumer without spending a ridiculous amount of time mocking the amqp library. There’s a test in <a href="https://github.com/callistaenterprise/goblog/blob/P9/common/messaging/messagingclient_test.go">messagingclient_test.go</a> that tests the subscriber loop that waits indefinitely for incoming messages to process, but that’s it.</p>

<p>For more thorough testing of messaging, I’ll <strong>probably</strong> return to that topic in a future blog post about <em>integration testing</em> Go microservices using <em>go test</em> with the Docker Remote API or Docker Compose. The test would boot supporting services such as RabbitMQ it can use to send and receive actual messages in test code.</p>

<h1 id="footprint-and-performance">Footprint and performance</h1>
<p>Won’t do performance tests this time around, a quick peek at memory use after sending and receiving some messages will have to suffice:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   CONTAINER                                    CPU %               MEM USAGE / LIMIT
   vipservice.1.tt47bgnmhef82ajyd9s5hvzs1       0.00%               1.859MiB / 1.955GiB
   accountservice.1.w3l6okdqbqnqz62tg618szsoj   0.00%               3.434MiB / 1.955GiB
   rabbitmq.1.i2ixydimyleow0yivaw39xbom         0.51%               129.9MiB / 1.955GiB
</code></pre></div></div>

<p>The above is after serving a few requests. The new “vipservice” is not as complex as the “accountservice” so it’s expected it uses less RAM after startup.</p>

<h1 id="summary">Summary</h1>

<p>That was probably the longest part of the <a href="../../../02/17/go-blog-series-part1.html">series</a> this far! We’ve accomplished:</p>

<ul>
  <li>Examined RabbitMQ and the AMQP mechanics in more depth.</li>
  <li>Added a brand-new “vipservice”.</li>
  <li>Extracted messaging (and config) code into a reusable sub-project.</li>
  <li>Publish / Subscribe of messages using the AMQP protocol.</li>
  <li>Mock code generation with mockery.</li>
</ul>

<p>In <a href="../../../08/02/go-blog-series-part10.html">part 10</a>, we’ll do something more lightweight but just as important for a real-world operations model - structured logging using Logrus, the Docker GELF log driver and publishing logs to a <a href="https://en.wikipedia.org/wiki/Logging_as_a_service">LaaS</a> provider.</p>










            <div class="ce-blog-thanks">
              Tack för att du läser Callistas blogg. <br>
              Hjälp oss att nå ut med information genom att dela nyheter och artiklar i ditt nätverk.<br>
            </div>

            


    
<div class="ce-blog-share">
    <a class="ce-blog-share-element social-twitter" href="https://twitter.com/intent/tweet?text=Go Blog Series Part9&url=https://callistaenterprise.se/blogg/teknik/2017/06/08/go-blog-series-part9/&via=callistaent&hashtags=" target="_blank" title="Share this post on Twitter"></a>
    <a class="ce-blog-share-element social-facebook" href="https://www.facebook.com/sharer/sharer.php?t=Go Blog Series Part9&u=https://callistaenterprise.se/blogg/teknik/2017/06/08/go-blog-series-part9/" target="_blank" title="Share this post on Facebook"></a>
    <a class="ce-blog-share-element social-linkedin" href="http://www.linkedin.com/shareArticle?mini=true&title=Go Blog Series Part9&url=https://callistaenterprise.se/blogg/teknik/2017/06/08/go-blog-series-part9/&source=http%3a%2f%2fzhangwenli.com" target="_blank" title="Share this post on LinkedIn"></a>
</div>
    
        </article>
    </div>
</section>


<section class="ce-section">
    <heading>
        <h1>Kommentarer</h1>
    </heading>
    <div class="ce-content">
        <div id="disqus_thread"></div>
        <script src="../../../../../../js/disqus.js"></script>
    </div>
</section>


    </div>

    <footer class="ce-footer">
    <div class="ce-wrapper">
        <nav class="ce-menu-footer-primary">
            <h2><a href="../../../../../../index.html">Callista</a></h2>
            <ul>
                
                <li><a href="../../../../../../om/index.html">Om oss</a></li>
                
                <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                
                <li><a href="../../../../../../event.html">Event</a></li>
                
                <li><a href="../../../../../../blogg.html">Blogg</a></li>
                
                <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                

                
                    
                        <li><a href="../../../../../../english/index.html">English</a></li>
                    
                
            </ul>
        </nav>
        <div class="ce-addresses">
            <div class="ce-address">
                <h2>Stockholm</h2>
                <address>
                    Drottninggatan 55<br>
                    111 21 Stockholm<br>
                    Tel:
                    <a href="tel:+468212142">
                        +46 8 21 21 42
                    </a>
                </address>
            </div>
            <div class="ce-address">
                <h2>Göteborg</h2>
                <address>
                    Fabriksgatan 13<br>
                    412 50 Göteborg<br>
                    Tel:
                    <a href="tel:+4631201918">
                        +46 31 20 19 18
                    </a>
                </address>
            </div>
        </div>
        <div class="ce-social">
            <h2>Följ oss</h2>
            <ul>
                <li>
                    <a href="http://twitter.com/callistaent">
                        <img alt="Twitters logotype" src="../../../../../../images/icons/twitter.png">
                        <span>@callistaent</span>
                    </a>
                </li>
            </ul>
        </div>
        <small>&copy; 2021 Callista Enterprise AB</small>
        <hr style="margin: 1em 0 2em 0">
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-raddabarnen" href="http://www.raddabarnen.se/foretag">
                <img alt="Callista är Rädda Barnens företagsvän 2021" src="../../../../../../images/logotype/rb_vanforetag_2021_large-sv.png">
            </a>
          </div>
        </div>
        <br>
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-di-gasell" href="http://www.di.se/gasell/">
              <img alt="Callista utsett till DI Gasell tre år i rad" src="../../../../../../images/logotype/di_gasell_180x194.png">
            </a>
          </div>
        </div>
    </div>
</footer>


    <script src="../../../../../../js/lib/jquery.min.js"></script>
    <script src="../../../../../../js/lib/owl.carousel.min.js"></script>
    <script src="../../../../../../js/lib/prismjs.min.js"></script>
    <script src="../../../../../../js/app.js"></script>
    <script src="../../../../../../js/analytics.js"></script>
    <script src="../../../../../../js/jobinterestsubmit.js"></script>

</body>
</html>
