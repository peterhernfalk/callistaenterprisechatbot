<!DOCTYPE html>
<html lang="sv-se">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Callista Enterprise - seniora IT-arkitekter och systemutvecklare inom Java, öppen källkod, agil utveckling och systemintegration">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
    <meta name="viewport" content="initial-scale=1.0001, minimum-scale=1.0001, maximum-scale=1.0001, user-scalable=no"/>

    <link rel="icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="shortcut icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="apple-touch-icon" href="../../../../../../images/icons/callista_favicon_160x160.png">

    <title>Go microservices, part 5 - deploying on Docker Swarm | Callista</title>

    <link rel="stylesheet" href="../../../../../../css/style.css%3Fv=1.css">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for callistaenterprise.se" href="../../../../../../feed.xml" />

    <!--[if lte IE 8]>
    <style>* { display: none !important; }</style>
    <meta http-equiv="refresh" content="0; url=/oldie/"/>
    <![endif]-->

    <script type="text/javascript" src="https://use.typekit.net/kig5egm.js"></script>
    <script type="text/javascript">
        try {
            Typekit.load({ async: true });
        } catch (e) {
        }
    </script>

    <!-- Facebook Pixel Code -->
    <script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window,document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
     fbq('init', '804675599711872');
     fbq('track', 'PageView');
    </script>
    <noscript>
     <img height="1" width="1" src="https://www.facebook.com/tr?id=804675599711872&ev=PageView&noscript=1"/>
    </noscript>
    <!-- End Facebook Pixel Code -->

</head>
<body>

    <header class="ce-header" data-scroll="0">
    <nav>
        <img alt="menubg" class="ce-menu-icon" style="z-index:3; top: 0px; width: 50px; height: 100%;" src="../../../../../../images/icons/menu_background.png">
        <a class="ce-logotype" href="../../../../../../index.html" style="z-index: 2;">
            <img alt="Callista" style="max-width: 100%; height: auto;" src="../../../../../../images/logotype/callista_small2.svg">
        </a>
        <table>
            <tr>
                <td>
            <ul id="menu-primary" class="ce-menu-primary">
                
                    
                            <li><a href="../../../../../../om/index.html">Om oss</a></li>
                    
                
                    
                            <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                    
                
                    
                            <li><a href="../../../../../../event.html">Event</a></li>
                    
                
                    
                        
                            <li><a class="ce-active" href="../../../../../../blogg.html">Blogg</a></li>
                        
                    
                
                    
                            <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                    
                
            </ul>
                </td>

                <td>
            <ul class="ce-menu-secondary">
                
                <li><a href="../../../../../../english/index.html">English</a></li>
                
            </ul>
                </td>
            </tr>
        </table>
            <a id="menu" class="ce-menu-icon" href="../go-blog-series-part5.html#" style="z-index: 4;">
                <img alt="Visa meny" src="../../../../../../images/icons/menu.png">
            </a>
            <a class="ce-search-icon" href="../go-blog-series-part5.html#">
                <img alt="Sök" src="../../../../../../images/icons/search.png">
            </a>

        </table>
    </nav>
</header>


    <div class="ce-main">
        <section class="ce-start lazyImg">
    <article>
        <h1>Blogg</h1>
        <p class="ce-ingress">
            Här finns tekniska artiklar, presentationer och nyheter om arkitektur och systemutveckling. Håll dig uppdaterad, följ oss på <a class="ce-active" href="http://twitter.com/callistaent">Twitter</a>
        </p>
    </article>
</section>

<section class="ce-section">
    <div class="ce-content">
        
        

        
        

        <article class="ce-blog">
            <header>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <img alt="Callista medarbetare Erik Lupander" src="../../../../../../assets/medarbetare/eriklupander_mini.png">
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <h2>
        <a href="../go-blog-series-part5.html">Go microservices, part 5 - deploying on Docker Swarm</a>
        
        
    </h2>
    <h3>
        <time datetime="2017-03-09T00:00:00+00:00">
            09 March 2017
        </time>
        //
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        <a href="../../../../../../om/medarbetare/eriklupander/index.html">Erik Lupander</a>
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </h3>
    
</header>




<p>In part 5, we’ll get our “accountservice” up and running on a locally deployed <a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a> cluster and discuss the core concepts of container orchestration.</p>

<p>This blog post deals with the following:</p>

<ul>
  <li>Docker Swarm and container orchestration</li>
  <li>Containerize our accountservice using Docker</li>
  <li>Setting up a local Docker Swarm cluster</li>
  <li>Deploying the accountservice as a Swarm Service</li>
  <li>Run the benchmarks and collect metrics</li>
</ul>

<p><em>Gophers beware: After writing this part of the <a href="../../../02/17/go-blog-series-part1.html">blog series</a>, I realized there’s nothing Go-specific in this part. I hope you’ll enjoy it anyway.</em></p>

<h1 id="what-is-a-container-orchestrator">What is a container orchestrator?</h1>
<p>Before going practical, a quick introduction of the concept of a “container orchestrator” may be of use.</p>

<p>As an application becomes more complex and has to handle an (hopefully) ever higher load, we have to deal with the fact that we could be running hundreds of service instances spread out over a lot of physical (or virtualized) hardware. Container orchestration allows us to view all that hardware as a single logical entity.</p>

<p>This article about <a href="https://thenewstack.io/containers-container-orchestration/">container orchestration</a> from <a href="https://thenewstack.io">thenewstack.io</a> sums it up as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"abstracting the host infrastructure, orchestration tools allow users to treat the entire cluster as a single deployment target."
</code></pre></div></div>

<p>I can’t summarize it better myself - using a container orchestrator such as Kubernetes or Docker Swarm allows us to deploy our software components as <a href="https://docs.docker.com/engine/swarm/key-concepts/">services</a> running on one or more nodes of our available infrastructure. In the case of Docker - the Swarm mode is about managing a cluster of Docker Engines called a swarm. Kubernetes uses a slightly different nomenclature and hierarchy of key abstractions, but the concept on the whole is roughly the same.</p>

<p>The container orchestrator not only handles the lifecycle of our service for us, it also provides mechanics for things like service discovery, load-balancing, internal addressing and logging.</p>

<h1 id="the-core-concepts-of-docker-swarm">The core concepts of Docker Swarm</h1>
<p>In Docker Swarm, there’s three concepts that entails an introduction:</p>

<ul>
  <li>Node: A node is an instance of the Docker engine participating in the swarm. Technically, see it as a host having it’s own CPU resources, memory and network interface. A node can be either a <em>manager node</em> or a <em>worker node</em>.</li>
  <li>Service: A service is the definition of what to execute on the worker nodes as defined by a container image and the commands you instruct the container(s) to execute. A service can be <a href="https://docs.docker.com/engine/swarm/services/#/control-service-scale-and-placement">either</a> <em>replicated</em> or <em>global</em>, see the docs for details. A service can be seen as an abstraction for letting an arbitrary number of containers form a logical “service” accessible through its name throughout and possibly outside the cluster without having to know anything about the internal network topology of the environment.</li>
  <li>Task (e.g. container): For all practical means, consider a task a Docker container. The Docker docs defines a task as something that “carries a Docker container and the commands to run inside the container”. Manager nodes assigns the <em>task</em> of starting a container running a given container image as specified in a <em>service</em> to a (worker) <em>node</em>.</li>
</ul>

<p>The diagram below shows a possible (simplified) deployment of our microservice landscape with two nodes running a total of five container instances abstracted by two services - “accountservice” and “quotes-service”.</p>

<p><img src="../../../../../../assets/blogg/goblog/part5-swarm-overview.png" alt="swarm overview" /></p>

<h1 id="source-code">Source code</h1>
<p>While this part doesn’t change any of the Go code from the previous parts, we’re going to add some new files for running on Docker. Feel free to checkout the appropriate branch from git to get the source of the completed state of this part.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout P5
</code></pre></div></div>

<p><em>Note: Most of the Go source code for the blog series was rewritten in July 2019 to better reflect contemporary idiomatic Go coding guidelines and design patterns. However, the corresponding <a href="https://github.com/callistaenterprise/goblog/tree/P5">git branch</a> for each part of the series remains unchanged in order to stay aligned with the content of each installment. For the latest and greatest code, look at the <a href="https://github.com/callistaenterprise/goblog">master</a> branch in github.</em></p>

<h1 id="containerize-our-accountservice">Containerize our accountservice</h1>

<h2 id="docker-installation">Docker installation</h2>
<p>For this part to work, you’ll need to have Docker installed on your dev machine. I suggest following <a href="https://docs.docker.com/engine/installation/">this guide</a> for your Operating System. Personally, I’ve used Docker Toolbox with Virtualbox when developing the code for this blog series, but you could just as well use Docker for <a href="https://docs.docker.com/docker-for-mac/">Mac</a>/<a href="https://docs.docker.com/docker-for-windows/">Windows</a> or run Docker natively on <a href="https://docs.docker.com/engine/getstarted/step_one/#/docker-for-linux">Linux</a>.</p>

<h2 id="creating-a-dockerfile">Creating a Dockerfile</h2>
<p>A <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> is the recipe used by Docker for building a <a href="https://docs.docker.com/engine/getstarted/step_two/">docker container image</a> containing whatever you want it to contain. Let’s get this started by creating a file called <em>Dockerfile</em> in the <em>/accountservice</em> folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM iron/base

EXPOSE 6767
ADD accountservice-linux-amd64 /
ENTRYPOINT ["./accountservice-linux-amd64"]
</code></pre></div></div>

<p>A quick explanation:</p>
<ul>
  <li>FROM - defines the base image that we’ll start building our own image from. iron/base is a very compact image well suited for running a Go application.</li>
  <li>EXPOSE - defines a port number we want to expose on the internal Docker network so it becomes reachable.</li>
  <li>ADD - Adds a file <em>accountservice-linux-amd64</em> to the root ( / ) of the container filesystem.</li>
  <li>ENTRYPOINT - defines what executable to run when Docker starts a container of this image.</li>
</ul>

<h2 id="building-for-another-cpu-architecture--operating-system">Building for another CPU architecture / operating system</h2>
<p>As you see, the file we’re adding has this “linux-amd64” in its name. While we can name a Go executable just about anything, I like using a convention where we put the OS and target CPU platform into the executable name. I’m writing this blog series on a Mac running OS X. So if I just build a go executable of our accountservice from the commandline when in the <em>/goblog/accountservice</em> folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; go build
</code></pre></div></div>

<p>That will create an executable called <em>accountservice</em> in the same folder. The problem with that executable is that it won’t run in our Docker container as the underlying OS there is Linux-based. Therefore, we need to set a few Environment variables before building so the go compiler and linker knows we’re building for another OS and/or CPU architecture - in our case Linux.</p>

<p>Again, from the <em>/goblog/accountservice</em> folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; export GOOS=linux
&gt; go build -o accountservice-linux-amd64
&gt; export GOOS=darwin
</code></pre></div></div>

<p>This produces an executable binary named using the <em>-o</em> flag. I usually brew my own little shell script that automates this for me.</p>

<p>Since both OS X and our Linux-based container runs on the AMD64 CPU architecture we don’t need to set (and reset) the <a href="https://golang.org/pkg/runtime/#pkg-constants">GOARCH</a> env var. But if you’re building something for an 32-bit OS or perhaps an ARM processor you would need to set GOARCH appropriately before building.</p>

<h2 id="creating-a-docker-image">Creating a Docker image</h2>
<p>Now it’s time to build our very first Docker image containing our executable. Go to the parent folder of the <em>/accountservice</em> folder, it should be <em>$GOPATH/src/github.com/callistaenterprise/goblog</em>.</p>

<p>When building a Docker container image, we usually tag it with a name usually using a [prefix]/[name] naming convention. I typically use my github username as prefix, e.g. <em>eriklupander/myservicename</em>. For this blog series, I’ll use “someprefix”.
Execute the following command from the root project folder (e.g. <em>/goblog</em>) to build a Docker image based on the Dockerfile above:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker build -t someprefix/accountservice accountservice/

Sending build context to Docker daemon 13.17 MB
Step 1/4 : FROM iron/base
 ---&gt; b65946736b2c
Step 2/4 : EXPOSE 6767
 ---&gt; Using cache
 ---&gt; f1147fd9abcf
Step 3/4 : ADD accountservice-linux-amd64 /
 ---&gt; 0841289965c6
Removing intermediate container db3176c5e1e1
Step 4/4 : ENTRYPOINT ./accountservice-linux-amd64
 ---&gt; Running in f99a911fd551
 ---&gt; e5700191acf2
Removing intermediate container f99a911fd551
Successfully built e5700191acf2
</code></pre></div></div>

<p>Nice! Our local docker image repository now contains an image named <em>someprefix/accountservice</em>. If we’d be running with multiple nodes or if we’d want to share our new image, we’d use <a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a> to make the image available for hosts other than our currently active Docker Engine provider host to <a href="https://docs.docker.com/engine/reference/commandline/pull/">pull</a>.</p>

<p>We can now try to run this image directly from the command line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker run --rm someprefix/accountservice
Starting accountservice
Seeded 100 fake accounts...
2017/02/05 11:52:01 Starting HTTP service at 6767
</code></pre></div></div>

<p>However - note that this container is <em>not</em> running on your host OS localhost anymore. It now lives in it’s own networking context and we can’t actually call it directly from our host operating system. There are ways to fix that of course, but instead of going down that route we’ll now set up Docker Swarm locally and deploy our “accountservice” there instead.</p>

<p>Use Ctrl+C to stop the container we just started.</p>

<h1 id="setting-up-a-single-node-docker-swarm-cluster">Setting up a single-node Docker Swarm cluster</h1>
<p>One of the goals of this blog series is that we want to run our microservices inside a container orchestrator. For many of us, that typically means Kubernetes or Docker Swarm. There are other orchestrators as well such as <a href="http://mesos.apache.org/">Apache Mesos</a> and <a href="https://www.apcera.com/platform">Apcera</a>, but this blog series will focus exclusively on Docker Swarm based on Docker 1.13.</p>

<p>The tasks involved when setting up a Docker Swarm cluster on your dev computer may vary somewhat depending on how you installed Docker itself. I suggest following <a href="https://docs.docker.com/engine/swarm/swarm-tutorial/">this guide</a> or you can try to do it using <a href="https://github.com/callistaenterprise/goblog/blob/master/extras/docker-setup.md">my approach</a> using Docker Toolbox, Oracle Virtualbox and docker-machine that based on my colleague Magnus lab-repo regarding service discovery found <a href="https://github.com/callistaenterprise/cadec-2017-service-discovery">here</a>.</p>

<h2 id="create-a-swarm-manager">Create a Swarm Manager</h2>

<p>A Docker Swarm cluster consists of at least one Swarm Manager and zero to many Swarm Workers. To keep things simple, my examples will just use a single Swarm Manager - at least for now. The important thing is that after this section you need to have a working Swarm Manager up and running.</p>

<p>The example here uses <a href="https://docs.docker.com/machine/overview/">docker-machine</a> and makes a virtual linux machine running on Virtualbox my Swarm Manager. It’s referred to as “swarm-manager-1” in my examples. You can also take a peek at the <a href="https://docs.docker.com/engine/swarm/swarm-tutorial/create-swarm/">offical documentation</a> on how to create a Swarm.</p>

<p>This command initializes the docker-machine host identified as <em>swarm-manager-1</em> as a swarm node with the IP address of the same <em>swarm-manager-1</em> node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker $(docker-machine config swarm-manager-1) swarm init --advertise-addr $(docker-machine ip swarm-manager-1)
</code></pre></div></div>

<p>If we’d be creating a multi-node swarm cluster we’d make sure to store the <em>join-token</em> emitted by the command above as we’d need it later if we were to add additional nodes to the swarm.</p>

<h2 id="create-an-overlay-network">Create an overlay network</h2>
<p>A docker <a href="https://docs.docker.com/engine/userguide/networking/#/an-overlay-network-with-docker-engine-swarm-mode">overlay network</a> is a mechanism we use when adding services such as our “accountservice” to the Swarm so it can access other containers running in the same Swarm cluster without having to know anything about the actual cluster topology. Let’s create such a network:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create --driver overlay my_network
</code></pre></div></div>

<p><em>my_network</em> is the name we gave the network.</p>

<h1 id="deploying-the-accountservice">Deploying the accountservice</h1>
<p>Almost there! Now it’s time to deploy our “accountservice” as a <a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/">Docker Swarm service</a>. The <em>docker service create</em> command takes a lot of parameters but isn’t that scary, promise. Here’s the command we’ll execute to deploy the “accountservice”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service create --name=accountservice --replicas=1 --network=my_network -p=6767:6767 someprefix/accountservice
ntg3zsgb3f7ah4l90sfh43kud
</code></pre></div></div>

<p>Here’s a quick rundown of the arguments:</p>

<ul>
  <li>–name: Assigns a logical name to our service. This is also the name other services will use when addressing our service within the cluster. So if you had a another service that would like to call the <em>accountservice</em>, that service would just do a GET to <em>http://accountservice:6767/accounts/10000</em></li>
  <li>–replicas: The number of instances of our service we want. If we’d have a multi-node Docker Swarm cluster the swarm engine would automatically distribute the instances across the nodes.</li>
  <li>–network: Here we tell our service to attach itself to the overlay network we just created.</li>
  <li>-p: Maps [internal port]:[external port]. Here we used 6767:6767 but if we’d created it using 6767:80 then we would access the service from port 80 when calling externally. Note that this is the mechanism that makes our service reachable from outside the cluster. Normally, you shouldn’t expose your services directly to the outside world. Instead, you’d be using an EDGE-server (e.g. a reverse proxy) that would have routing rules and security setup so external consumers wouldn’t be able to reach your services except in the way you’ve intended them to.</li>
  <li>someprefix/accountservice: This how we specify <em>which</em> image we want the container to run. In our case this is the tag we specified when we created the container. Note! If we’d be running a multi-node cluster we would have had to push our image to a Docker repository such as the public (and free) Docker Hub service. One can also set up private docker repositories or use a paid service if you want your images to stay private.</li>
</ul>

<p>That’s it. Run this to see if our service was started successfully.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service ls
ID            NAME               REPLICAS  IMAGE                      
ntg3zsgb3f7a  accountservice     1/1       someprefix/accountservice
</code></pre></div></div>

<p>Sweet. We should now be able to curl or even use a web browser to query our API. The only thing we need to know up front is the public IP of the Swarm. Even if we’re running only one instance of our service on a swarm with many nodes, the overlay network and Docker Swarm lets us ask <em>any</em> of the swarm hosts for our service based on its port. That also means that two services cannot expose <em>the same</em> port externally. They may very well have the same port <em>internally</em> but to the outside world - the Swarm is one.</p>

<p>Anyway - remember that environment variable <em>ManagerIP</em> we saved earlier?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; echo $ManagerIP
192.168.99.100
</code></pre></div></div>

<p>If you’ve changed your terminal session since then, you can re-export it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; export ManagerIP=`docker-machine ip swarm-manager-0`
</code></pre></div></div>

<p>Let’s curl:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; curl $ManagerIP:6767/accounts/10000
{"id":"10000","name":"Person_0"}
</code></pre></div></div>

<p>It’s alive!</p>

<h2 id="deploy-a-visualizer">Deploy a visualizer</h2>
<p>While using the Docker command-line API to examine the state of your Swarm (such as <em>docker service ls</em>) is fully viable, a more graphical representation may be interesting to look at. Such a visualizer is <a href="https://github.com/ManoMarks/docker-swarm-visualizer">manomarks Docker Swarm Visualizer</a> that we can deploy as a Docker Swarm service. This provides us with an alternate mechanism for looking at our cluster topology. It can also be used just for making sure we can reach a service exposed at a given port within our cluster.</p>

<p>Installing the visualizer from a pre-baked container image is a one-liner:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service create \
  --name=viz \
  --publish=8080:8000/tcp \
  --constraint=node.role==manager \
  --mount=type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \
  manomarks/visualizer
</code></pre></div></div>

<p>This creates a service we can access at port 8000. Direct your browser to <em>http://$ManagerIP:8000</em>:</p>

<p><img src="../../../../../../assets/blogg/goblog/part5-viz.png" alt="viz" /></p>

<h4 id="bonus-content">Bonus content!</h4>
<p>I’ve made a little Swarm visualizer myself called <a href="https://github.com/eriklupander/dvizz">“dvizz”</a> using Go, the Docker Remote API and <a href="https://d3js.org/">D3.js</a> force graphs. You can install it directly from a pre-baked image if you like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> docker service create \
   --constraint node.role==manager \
   --replicas 1 --name dvizz -p 6969:6969 \
   --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock \
   --network my_network \
   eriklupander/dvizz
</code></pre></div></div>

<p>Direct your browser to <em>http://$ManagerIP:6969</em>:</p>

<p><img src="../../../../../../assets/blogg/goblog/part5-dvizz.png" alt="dvizz" /></p>

<p>It’s a bit buggy so don’t take it too seriously, but it’s rather fun to look at that graph bouncing around when scaling services up and down - something we’ll do in part 7 of the blog series. Feel free to branch dvizz or submit a pull request if you want to help making it even cooler, more useful or less buggy!</p>

<h2 id="adding-the-quotes-service">Adding the quotes-service</h2>
<p>Not much of a Microservice landscape with only one type of service (our ubiquitous accountservice) in it. Let’s remedy that by deploying the Spring Boot-based “<em>quotes-service</em>” previously mentioned directly from a <a href="https://hub.docker.com/r/eriklupander/quotes-service/">container image</a> I’ve pushed to <a href="https://hub.docker.com">Docker Hub</a> tagged as <em>eriklupander/quotes-service</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service create --name=quotes-service --replicas=1 --network=my_network eriklupander/quotes-service
</code></pre></div></div>

<p>If you do a <em>docker ps</em> to list running Docker containers we should see it started (or starting):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker ps
CONTAINER ID    IMAGE                       COMMAND                 CREATED         STATUS                           PORTS                                           NAMES
98867f3514a1    eriklupander/quotes-service "java -Djava.security"  12 seconds ago  Up 10 seconds (health: starting) 8080/tcp 
</code></pre></div></div>

<p>Note that we’re not exporting a port mapping for this service which means it won’t be reachable from outside of the Swarm cluster, only internally on port 8080. We’ll integrate with this service later on in Part 7 when we’ll be looking at Service Discovery and load-balancing.</p>

<p>If you added “dvizz” to your Swarm, it should show something like this now that we’ve added the “quotes-service” and “accountservice”.</p>

<p><img src="../../../../../../assets/blogg/goblog/part5-dvizz3.png" alt="dvizz2" /></p>

<h2 id="the-copyallsh-script">The copyall.sh script</h2>
<p>To make things a little easier for us along the way, we can add a shell script to automate things for us when rebuilding/redeploying. In the root <em>/goblog</em> folder, create a shell script named <em>copyall.sh</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
export GOOS=linux
export CGO_ENABLED=0

cd accountservice;go get;go build -o accountservice-linux-amd64;echo built `pwd`;cd ..

export GOOS=darwin

docker build -t someprefix/accountservice accountservice/

docker service rm accountservice
docker service create --name=accountservice --replicas=1 --network=my_network -p=6767:6767 someprefix/accountservice
</code></pre></div></div>

<p>This script sets up environment variables so we safely can build a statically linked binary for Linux/AMD64, does this and then runs a few Docker commands to (re)build the image and (re)deploy it as a Docker Swarm service. Saves time when prototyping!</p>

<p>Build scripts for Go is a topic I won’t dive into in this blog series. Personally, I like the simplicity of shell scripts, though I’ve occasionally used a <a href="https://plugins.gradle.org/plugin/org.echocat.golang">gradle plugin</a> myself and I know good ol’ <a href="https://www.gnu.org/software/make/">make</a> is quite popular as well.</p>

<h1 id="footprint-and-performance">Footprint and performance</h1>
<p>From now on, all benchmarking and collection of CPU/memory metrics will happen on the service when its running inside the Docker Swarm. This means the results from previous blog posts isn’t comparable to what we’re going to get from now on.</p>

<p>Both CPU utilization and memory use will be collected using <em>docker stats</em> while we’re going to use the same Gatling test as before.</p>

<p>If you feel like running the load tests yourself, the requirements for this introduced in Part 2 still applies. Just note that you’ll need to change the <em>-baseUrl=</em> argument to the IP of your Swarm Manager node, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mvn gatling:execute -Dusers=1000 -Dduration=30 -DbaseUrl=http://$ManagerIP:6767
</code></pre></div></div>

<h2 id="memory-usage-after-startup">Memory usage after startup</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker stats $(docker ps | awk '{if(NR&gt;1) print $NF}')

CONTAINER                                    CPU %               MEM USAGE / LIMIT    
accountservice.1.k8vyt3dulvng9l6y4mj14ncw9   0.00%               5.621 MiB / 1.955 GiB
quotes-service.1.h07fde0ejxru4pqwwgms9qt00   0.06%               293.9 MiB / 1.955 GiB
</code></pre></div></div>

<p>Right after startup, the container consisting of a bare linux distro and our running “accountservice” uses ~5.6 mb of RAM out of the 2GB I’ve allocated to the Docker Swarm node. The Java-based quotes-service hovers just under 300 mb - though it should be said that it certainly can be reduced somewhat by tuning its JVM.</p>

<h2 id="cpu-and-memory-usage-during-load-test">CPU and memory usage during load test</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONTAINER                                    CPU %               MEM USAGE / LIMIT   
accountservice.1.k8vyt3dulvng9l6y4mj14ncw9   25.50%              35.15 MiB / 1.955 GiBB
</code></pre></div></div>

<p>At 1K req/s within the Swarm running on a Virtualbox instance instead of native OS X as in part 2 and 3, we see numbers pretty consistent with the earlier figures - as expected slightly higher memory use (after all, the container itself needs a few Mb) and a roughly similar CPU utilization.</p>

<h2 id="performance">Performance</h2>

<p><img src="../../../../../../assets/blogg/goblog/part5-performance.png" alt="performance" /></p>

<p>The mean latency is now up to 4 ms. The exact reason for this to increase from the sub-millisecond mean when running directly could be several, I’m guessing there’s an overhead involved when the Gatling test that’s running on the native OS accesses the Swarm running on a virtualized instance with a bridged network and some perhaps some routing going on within the Swarm and it’s own overlay network. It’s still really nice to be able to serve a peak of 1K req/s at a 4ms mean latency including reading from the BoltDB, serializing to JSON and serving it over HTTP.</p>

<p>In case we need to greatly decrease the number of req/s in later blog posts due to large overhead when adding things like tracing, logging, circuit breakers or whatnot - here’s a figure when running 200 req/s:</p>

<p><img src="../../../../../../assets/blogg/goblog/part5-performance200.png" alt="performance200" /></p>

<h1 id="summary">Summary</h1>
<p>This sums up part 5 of the blog series where we have learned how to bootstrap a Docker Swarm landscape (with one node) locally and how to package and deploy our “accountservice” microservice as a Docker Swarm Service.</p>

<p>In <a href="../../22/go-blog-series-part6.html">part 6</a>, we’ll add a Healthcheck to our microservice.</p>









            <div class="ce-blog-thanks">
              Tack för att du läser Callistas blogg. <br>
              Hjälp oss att nå ut med information genom att dela nyheter och artiklar i ditt nätverk.<br>
            </div>

            


    
<div class="ce-blog-share">
    <a class="ce-blog-share-element social-twitter" href="https://twitter.com/intent/tweet?text=Go Blog Series Part5&url=https://callistaenterprise.se/blogg/teknik/2017/03/09/go-blog-series-part5/&via=callistaent&hashtags=" target="_blank" title="Share this post on Twitter"></a>
    <a class="ce-blog-share-element social-facebook" href="https://www.facebook.com/sharer/sharer.php?t=Go Blog Series Part5&u=https://callistaenterprise.se/blogg/teknik/2017/03/09/go-blog-series-part5/" target="_blank" title="Share this post on Facebook"></a>
    <a class="ce-blog-share-element social-linkedin" href="http://www.linkedin.com/shareArticle?mini=true&title=Go Blog Series Part5&url=https://callistaenterprise.se/blogg/teknik/2017/03/09/go-blog-series-part5/&source=http%3a%2f%2fzhangwenli.com" target="_blank" title="Share this post on LinkedIn"></a>
</div>
    
        </article>
    </div>
</section>


<section class="ce-section">
    <heading>
        <h1>Kommentarer</h1>
    </heading>
    <div class="ce-content">
        <div id="disqus_thread"></div>
        <script src="../../../../../../js/disqus.js"></script>
    </div>
</section>


    </div>

    <footer class="ce-footer">
    <div class="ce-wrapper">
        <nav class="ce-menu-footer-primary">
            <h2><a href="../../../../../../index.html">Callista</a></h2>
            <ul>
                
                <li><a href="../../../../../../om/index.html">Om oss</a></li>
                
                <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                
                <li><a href="../../../../../../event.html">Event</a></li>
                
                <li><a href="../../../../../../blogg.html">Blogg</a></li>
                
                <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                

                
                    
                        <li><a href="../../../../../../english/index.html">English</a></li>
                    
                
            </ul>
        </nav>
        <div class="ce-addresses">
            <div class="ce-address">
                <h2>Stockholm</h2>
                <address>
                    Drottninggatan 55<br>
                    111 21 Stockholm<br>
                    Tel:
                    <a href="tel:+468212142">
                        +46 8 21 21 42
                    </a>
                </address>
            </div>
            <div class="ce-address">
                <h2>Göteborg</h2>
                <address>
                    Fabriksgatan 13<br>
                    412 50 Göteborg<br>
                    Tel:
                    <a href="tel:+4631201918">
                        +46 31 20 19 18
                    </a>
                </address>
            </div>
        </div>
        <div class="ce-social">
            <h2>Följ oss</h2>
            <ul>
                <li>
                    <a href="http://twitter.com/callistaent">
                        <img alt="Twitters logotype" src="../../../../../../images/icons/twitter.png">
                        <span>@callistaent</span>
                    </a>
                </li>
            </ul>
        </div>
        <small>&copy; 2021 Callista Enterprise AB</small>
        <hr style="margin: 1em 0 2em 0">
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-raddabarnen" href="http://www.raddabarnen.se/foretag">
                <img alt="Callista är Rädda Barnens företagsvän 2021" src="../../../../../../images/logotype/rb_vanforetag_2021_large-sv.png">
            </a>
          </div>
        </div>
        <br>
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-di-gasell" href="http://www.di.se/gasell/">
              <img alt="Callista utsett till DI Gasell tre år i rad" src="../../../../../../images/logotype/di_gasell_180x194.png">
            </a>
          </div>
        </div>
    </div>
</footer>


    <script src="../../../../../../js/lib/jquery.min.js"></script>
    <script src="../../../../../../js/lib/owl.carousel.min.js"></script>
    <script src="../../../../../../js/lib/prismjs.min.js"></script>
    <script src="../../../../../../js/app.js"></script>
    <script src="../../../../../../js/analytics.js"></script>
    <script src="../../../../../../js/jobinterestsubmit.js"></script>

</body>
</html>
