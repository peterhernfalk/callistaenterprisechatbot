<!DOCTYPE html>
<html lang="sv-se">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Callista Enterprise - seniora IT-arkitekter och systemutvecklare inom Java, öppen källkod, agil utveckling och systemintegration">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
    <meta name="viewport" content="initial-scale=1.0001, minimum-scale=1.0001, maximum-scale=1.0001, user-scalable=no"/>

    <link rel="icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="shortcut icon" href="../../../../../../images/icons/callista_favicon.svg" type="image/x-icon" />
    <link rel="apple-touch-icon" href="../../../../../../images/icons/callista_favicon_160x160.png">

    <title>Go Microservices, part 8 - centralized configuration with Viper and Spring Cloud Config | Callista</title>

    <link rel="stylesheet" href="../../../../../../css/style.css%3Fv=1.css">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for callistaenterprise.se" href="../../../../../../feed.xml" />

    <!--[if lte IE 8]>
    <style>* { display: none !important; }</style>
    <meta http-equiv="refresh" content="0; url=/oldie/"/>
    <![endif]-->

    <script type="text/javascript" src="https://use.typekit.net/kig5egm.js"></script>
    <script type="text/javascript">
        try {
            Typekit.load({ async: true });
        } catch (e) {
        }
    </script>

    <!-- Facebook Pixel Code -->
    <script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window,document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
     fbq('init', '804675599711872');
     fbq('track', 'PageView');
    </script>
    <noscript>
     <img height="1" width="1" src="https://www.facebook.com/tr?id=804675599711872&ev=PageView&noscript=1"/>
    </noscript>
    <!-- End Facebook Pixel Code -->

</head>
<body>

    <header class="ce-header" data-scroll="0">
    <nav>
        <img alt="menubg" class="ce-menu-icon" style="z-index:3; top: 0px; width: 50px; height: 100%;" src="../../../../../../images/icons/menu_background.png">
        <a class="ce-logotype" href="../../../../../../index.html" style="z-index: 2;">
            <img alt="Callista" style="max-width: 100%; height: auto;" src="../../../../../../images/logotype/callista_small2.svg">
        </a>
        <table>
            <tr>
                <td>
            <ul id="menu-primary" class="ce-menu-primary">
                
                    
                            <li><a href="../../../../../../om/index.html">Om oss</a></li>
                    
                
                    
                            <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                    
                
                    
                            <li><a href="../../../../../../event.html">Event</a></li>
                    
                
                    
                        
                            <li><a class="ce-active" href="../../../../../../blogg.html">Blogg</a></li>
                        
                    
                
                    
                            <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                    
                
            </ul>
                </td>

                <td>
            <ul class="ce-menu-secondary">
                
                <li><a href="../../../../../../english/index.html">English</a></li>
                
            </ul>
                </td>
            </tr>
        </table>
            <a id="menu" class="ce-menu-icon" href="../go-blog-series-part8.html#" style="z-index: 4;">
                <img alt="Visa meny" src="../../../../../../images/icons/menu.png">
            </a>
            <a class="ce-search-icon" href="../go-blog-series-part8.html#">
                <img alt="Sök" src="../../../../../../images/icons/search.png">
            </a>

        </table>
    </nav>
</header>


    <div class="ce-main">
        <section class="ce-start lazyImg">
    <article>
        <h1>Blogg</h1>
        <p class="ce-ingress">
            Här finns tekniska artiklar, presentationer och nyheter om arkitektur och systemutveckling. Håll dig uppdaterad, följ oss på <a class="ce-active" href="http://twitter.com/callistaent">Twitter</a>
        </p>
    </article>
</section>

<section class="ce-section">
    <div class="ce-content">
        
        

        
        

        <article class="ce-blog">
            <header>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <img alt="Callista medarbetare Erik Lupander" src="../../../../../../assets/medarbetare/eriklupander_mini.png">
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <h2>
        <a href="../go-blog-series-part8.html">Go Microservices, part 8 - centralized configuration with Viper and Spring Cloud Config</a>
        
        
    </h2>
    <h3>
        <time datetime="2017-05-15T00:00:00+00:00">
            15 May 2017
        </time>
        //
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        
        
        <a href="../../../../../../om/medarbetare/eriklupander/index.html">Erik Lupander</a>
        

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </h3>
    
</header>




<p>In part 8 of the <a href="../../../02/17/go-blog-series-part1.html">blog series</a>, we’ll explore centralized configuration for Go microservices with <a href="https://cloud.spring.io/spring-cloud-config/">Spring Cloud Config</a>.</p>

<h1 id="introduction">Introduction</h1>
<p>Centralizing something when dealing with Microservices may seem a bit off given that microservices after all is about decomposing your system into separate independent pieces of software. However, what we’re typically after is isolation of processes. Other aspects of microservice operations should be dealt with in a centralized way. For example, logs should end up in your logging solution such as the <a href="https://www.elastic.co/webinars/introduction-elk-stack">elk stack</a>, monitoring goes into a dedicated monitoring - in this part of the <a href="../../../02/17/go-blog-series-part1.html">blog series</a>, we’ll deal with externalized and centralized configuration using Spring Cloud Config and git.</p>

<p>Handling configuration for the various microservices that our application consists of in a centralized manner is actually quite natural as well. Especially when running in a containerized environment on an unknown number of underlying hardware nodes, managing config files built into each microservice image or from mounted volumes can quickly become a real headache. There are a number of proven projects to help deal with this, for example <a href="https://github.com/coreos/etcd">etcd</a>, <a href="https://www.consul.io/">consul</a> and <a href="https://zookeeper.apache.org/">zookeeper</a>. However, it should be noted that those projects provide a lot more than just serving configuration. Since this blog series focus on integrating Go microservices with the Spring Cloud / Netflix OSS ecosystem of supporting services, we’ll be basing our centralized configuration on <a href="https://cloud.spring.io/spring-cloud-config/">Spring Cloud Configuration</a>, a piece of software dedicated to provide exactly that.</p>

<p><em>Note: Most of the Go source code for the blog series was rewritten in July 2019 to better reflect contemporary idiomatic Go coding guidelines and design patterns. However, the corresponding <a href="https://github.com/callistaenterprise/goblog/tree/P8">git branch</a> for each part of the series remains unchanged in order to stay aligned with the content of each installment. For the latest and greatest code, look at the <a href="https://github.com/callistaenterprise/goblog">master</a> branch in github.</em></p>

<h1 id="spring-cloud-config">Spring Cloud Config</h1>
<p>The <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> ecosystem provides a solution for centralized configuration not-so-creatively named <a href="https://cloud.spring.io/spring-cloud-config/">Spring Cloud Config</a>. The Spring Cloud Config server can be viewed as a proxy between your services and their actual configuration, providing a number of really neat features such as:</p>

<ul>
  <li>Support for several different configuration backends such as git (default), file systems and plugins for using <a href="https://github.com/spring-cloud-incubator/spring-cloud-etcd/tree/master/spring-cloud-etcd-config">etcd</a>, <a href="https://github.com/spring-cloud/spring-cloud-consul/tree/master/spring-cloud-consul-config">consul</a> and <a href="https://github.com/spring-cloud/spring-cloud-zookeeper/tree/master/spring-cloud-starter-zookeeper-config">zookeeper</a> as stores.</li>
  <li>Transparent decryption of encrypted properties.</li>
  <li>Pluggable security</li>
  <li>Push mechanism using git hooks / REST API and Spring Cloud Bus (e.g. RabbitMQ) to propagate changes in config files to services, making live reload of configuration possible.</li>
</ul>

<p>For a more in-depth article about Spring Cloud Config in particular, take a look at my colleague Magnus recent <a href="../../12/building-microservices-part-6-configuration-server/index.html">blog post</a>.</p>

<p>In this blog post, we will integrate our “accountservice” with a Spring Cloud Config server backed by a public git repository on github, from which we’ll fetch configuration, encrypt/decrypt a property and also implement live-reload of config properties.</p>

<p>Here’s a simple overview of the overall solution we’re aiming for:</p>

<p><img src="../../../../../../assets/blogg/goblog/part8-springcloudconfig.png" alt="configserver.png" /></p>

<h1 id="overview">Overview</h1>
<p>Since we’re running Docker in Swarm mode, we’ll continue using Docker mechanics in various ways. Inside the Swarm, we should run at least one (perferrably more) instances of Spring Cloud Configuration servers. When one of our microservices starts up, all they need to know about are the following:</p>

<ul>
  <li>The logical service name and port of the config server. I.e - we’re deploying our config servers on Docker Swarm as services, let’s say we name that service “configserver”. That means that is the only thing the microservices needs to know about addressing in order to make a request for its configuration.</li>
  <li>What their name is, e.g. “accountservice”</li>
  <li>What execution profile it is running, e.g. “dev”, “test” or “prod”. If you’re familiar with the concept of <em>spring.profiles.active</em>, this is a home-brewn counterpart we can use for Go.</li>
  <li>If we’re using git as backend and want to fetch configuration from a particular branch, that needs to be known up front. (Optional)</li>
</ul>

<p>Given the four criteria above, a sample GET request for configuration could look like this in Go code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resp, err := http.Get("http://configserver:8888/accountservice/dev/P8")
</code></pre></div></div>

<p>I.e:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protocol://url:port/applicationName/profile/branch
</code></pre></div></div>

<h1 id="setting-up-a-spring-cloud-configuration-server-in-your-swarm">Setting up a Spring Cloud Configuration server in your Swarm</h1>
<p>For part 8, you’ll probably want to clone branch P8 since it includes the source for the config server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/callistaenterprise/goblog.git
git checkout P8
</code></pre></div></div>

<p>You could probably set up and deploy the config server in other ways. However, for simplicity I’ve prepared a <em>/support</em> folder in the root <em>/goblog</em> folder of the <a href="https://github.com/callistaenterprise/goblog/tree/P8/support">source code repository of the blog series</a> which will contain the requisite 3rd party services we’ll need further on.</p>

<p>Typically, each required support component will either be a simple <em>Dockerfile</em> for conveniently building and deploying components which we can use out of the box, or it will be (java) source code and configuration (Spring Cloud applications are usually based on Spring Boot) we’ll need to build ourselves using gradle. (No worries, all you need is to have a JDK installed).</p>

<p><em>(Most of these Spring Cloud applications were <a href="https://github.com/callistaenterprise/blog-microservices">prepared</a> by my colleague Magnus for his <a href="../../../../2015/05/20/blog-series-building-microservices.html">microservices blog series</a>.</em></p>

<p>Let’s get started with the config server, shall we?</p>

<h2 id="rabbitmq">RabbitMQ</h2>
<p>What? Weren’t we about to install Spring Cloud Configuration server? Well - that piece of software depends on having a message broker to propagate configuration changes using <a href="https://cloud.spring.io/spring-cloud-bus/">Spring Cloud Bus</a> backed by RabbitMQ. Having RabbitMQ around is a very good thing anyway which we’ll be using in a later blog post so we’ll start by getting RabbitMQ up and running as a service in our Swarm.</p>

<p>I’ve prepared a <a href="https://github.com/callistaenterprise/goblog/blob/P8/support/rabbitmq/Dockerfile">Dockerfile</a> inside <em>/goblog/support/rabbitmq</em> to use a pre-baked image which we’ll deploy as a Docker Swarm service.</p>

<p>We’ll create a new bash (.sh) script to automate things for us if/when we need to update things.</p>

<p>In the root <em>/goblog</em> folder, create a new file <em>support.sh</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

# RabbitMQ
docker service rm rabbitmq
docker build -t someprefix/rabbitmq support/rabbitmq/
docker service create --name=rabbitmq --replicas=1 --network=my_network -p 1883:1883 -p 5672:5672 -p 15672:15672 someprefix/rabbitmq
</code></pre></div></div>

<p>(You may need to chmod it to make it executable)</p>

<p>Run it and wait while Docker downloads the necessary images and deploys RabbitMQ into your Swarm. When it’s done, you should be able to open the RabbitMQ Admin GUI and log in using <em>guest/guest</em> at:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open http://$ManagerIP:15672/#/
</code></pre></div></div>

<p>Your web browser should open and display something like this:
<img src="../../../../../../assets/blogg/goblog/rabbitmq1.png" alt="rabbitmq" /></p>

<p>If you see the RabbitMQ admin GUI, we can be fairly sure it works as advertised.</p>

<h1 id="spring-cloud-configuration-server">Spring Cloud Configuration server</h1>
<p>In <em>/support/config-server</em> you’ll find a Spring Boot application pre-configured to run the config server. We’ll be using a <a href="https://github.com/eriklupander/go-microservice-config/tree/P8">git repository</a> for storing and accessing our configuration using <a href="https://en.wikipedia.org/wiki/YAML">yaml</a> files.</p>

<p>Feel free to take a look at <em>/goblog/support/config-server/src/main/resources/application.yml</em> which is the config file of the config server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
# For deployment in Docker containers
spring:
  profiles: docker
  cloud:
    config:
      server:
        git:
          uri: https://github.com/eriklupander/go-microservice-config.git
          
# Home-baked keystore for encryption. Of course, a real environment wouldn't expose passwords in a blog...          
encrypt:
  key-store:
    location: file:/server.jks
    password: letmein
    alias: goblogkey
    secret: changeme

# Since we're running in Docker Swarm mode, disable Eureka Service Discovery
eureka:
  client:
    enabled: false

# Spring Cloud Config requires rabbitmq, use the service name.
spring.rabbitmq.host: rabbitmq
spring.rabbitmq.port: 5672
</code></pre></div></div>

<p>We see a few things:</p>

<ul>
  <li>We’re telling the config-server to fetch configuration from our git-repo at the specified URI.</li>
  <li>A keystore for encryption (self-signed) and decryption (we’ll get back to that)</li>
  <li>Since we’re running in Docker Swarm mode, Eureka Service Discovery is disabled.</li>
  <li>The config server is expecting to find a rabbitmq host at “rabbitmq” which just happens to be the Docker Swarm service name we just gave our RabbitMQ service.</li>
</ul>

<p>The <em>Dockerfile</em> for the config-server is quite simple:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM davidcaste/alpine-java-unlimited-jce

EXPOSE 8888

ADD ./build/libs/*.jar app.jar
ADD ./server.jks /

ENTRYPOINT ["java","-Dspring.profiles.active=docker","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]
</code></pre></div></div>

<p>(Never mind that <em>java.security.egd</em> stuff, it’s a workaround for a problem we don’t care about in this blog series)</p>

<p>A few things of note here:</p>

<ul>
  <li>We’re using a base <a href="https://hub.docker.com/r/davidcaste/alpine-java-unlimited-jce/">docker image</a> based on Alpine Linux that has the Java unlimited cryptography extension installed, this is a requirement if we want to use the encryption/decryption features of Spring Cloud Config.</li>
  <li>A home-baked keystore is added to the root folder of the container image.</li>
</ul>

<h2 id="build-the-keystore">Build the keystore</h2>

<p>To use encrypted properties later on, we’ll configure the config server with a self-signed certificate. (You’ll need to have <em>keytool</em> on your PATH).</p>

<p>In the <em>/goblog/support/config-server/</em> folder, run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool -genkeypair -alias goblogkey -keyalg RSA \
-dname "CN=Go Blog,OU=Unit,O=Organization,L=City,S=State,C=SE" \  
-keypass changeme -keystore server.jks -storepass letmein \
-validity 730
</code></pre></div></div>

<p>This should create <em>server.jks</em>. Feel free to modify any properties/passwords, just remember to update <em>application.yml</em> accordingly!</p>

<h2 id="build-and-deploy">Build and deploy</h2>
<p>Time to build and deploy the server. Let’s create a shell script to save us time if or when we need to do this again. Remember - you need a Java Runtime Environment to build this! In the <em>/goblog</em> folder, create a file named <em>springcloud.sh</em>. We will put all things that actually needs building (and that may take some time) in there:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

cd support/config-server
./gradlew build
cd ../..
docker build -t someprefix/configserver support/config-server/
docker service rm configserver
docker service create --replicas 1 --name configserver -p 8888:8888 --network my_network --update-delay 10s --with-registry-auth  --update-parallelism 1 someprefix/configserver
</code></pre></div></div>

<p>Run it from the <em>/goblog</em> folder (you may need to chmod +x first):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./springcloud.sh
</code></pre></div></div>

<p>This may take a while, give it a minute or two and then check if you can see it up-and-running using <em>docker service</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker service ls

ID                  NAME                MODE                REPLICAS            IMAGE
39d26cc3zeor        rabbitmq            replicated          1/1                 someprefix/rabbitmq
eu00ii1zoe76        viz                 replicated          1/1                 manomarks/visualizer:latest
q36gw6ee6wry        accountservice      replicated          1/1                 someprefix/accountservice
t105u5bw2cld        quotes-service      replicated          1/1                 eriklupander/quotes-service:latest
urrfsu262e9i        dvizz               replicated          1/1                 eriklupander/dvizz:latest
w0jo03yx79mu        configserver        replicated          1/1                 someprefix/configserver
</code></pre></div></div>

<p>Try to manually load the “accountservice” configuration as JSON using curl:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     &gt; curl http://$ManagerIP:8888/accountservice/dev/master
     {"name":"accountservice","profiles":["dev"],"label":"master","version":"b8cfe2779e9604804e625135b96b4724ea378736",
     "propertySources":[
        {"name":"https://github.com/eriklupander/go-microservice-config.git/accountservice-dev.yml",
        "source":
            {"server_port":6767,"server_name":"Accountservice DEV"}
        }]
     }
</code></pre></div></div>

<p><em>(Formatted for brevity)</em></p>

<p>The actual configuration is stored within the “source” property where all values from the .yml file will appear as key-value pairs. Loading and parsing the “source” property into usable configuration in Go is the centerpiece of this blog post.</p>

<h1 id="the-yaml-config-files">The YAML config files</h1>
<p>Before moving on to Go code, let’s take a look inside the root folder of the P8 branch of the <a href="https://github.com/eriklupander/go-microservice-config/tree/P8">configuration-repo</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>accountservice-dev.yml
accountservice-test.yml
</code></pre></div></div>

<p>Both these files are currently very sparsely populated:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server_port: 6767
server_name: Accountservice TEST
the_password: (we'll get back to this one)
</code></pre></div></div>

<p>The only thing we’re configuring at this point is the HTTP port we want our service to bind to. A real service will probably have a lot more stuff in it.</p>

<h1 id="using-encryptiondecryption">Using encryption/decryption</h1>
<p>One really neat thing about Spring Cloud Config is its built-in support for transparently decrypting values encrypted directly in the configuration files. For example, take a look at <a href="https://github.com/eriklupander/go-microservice-config/blob/P8/accountservice-test.yml">accountservice-test.yml</a> where we have a dummy “the_password” property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server_port: 6767
server_name: Accountservice TEST
the_password: '{cipher}AQB1BMFCu5UsCcTWUwEQt293nPq0ElEFHHp5B2SZY8m4kUzzqxOFsMXHaH7SThNNjOUDGxRVkpPZEkdgo6aJFSPRzVF04SXOVZ6Rjg6hml1SAkLy/k1R/E0wp0RrgySbgh9nNEbhzqJz8OgaDvRdHO5VxzZGx8uj5KN+x6nrQobbIv6xTyVj9CSqJ/Btf/u1T8/OJ54vHwi5h1gSvdox67teta0vdpin2aSKKZ6w5LyQocRJbONUuHyP5roCONw0pklP+2zhrMCy0mXhCJSnjoHvqazmPRUkyGcjcY3LHjd39S2eoyDmyz944TKheI6rWtCfozLcIr/wAZwOTD5sIuA9q8a9nG2GppclGK7X649aYQynL+RUy1q7T7FbW/TzSBg='
</code></pre></div></div>

<p>By prefixing the encrypted string with <em>{cipher}</em>, our Spring Cloud configuration server will know how to automatically decrypt the value for us before passing the result to the service. In a running instance with everything configured correctly, a curl request to the REST API to fetch this config would return:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
      "source": {
        "server_port": 6767,
        "server_name": "Accountservice TEST",
        "the_password": "password"
....
</code></pre></div></div>

<p>Pretty neat, right? The “the_password” property can be stored as clear-text encrypted string on a public server (if you trust the encryption algorithm and the integrity of your signing key) and the Spring Cloud Config server (which may not under any circumstance be made available unsecured and/or visible outside of your internal cluster!!) transparently decrypts the property into actual value ‘password’.</p>

<p>Of course, you need to encrypt the value using the same key as Spring Cloud Config is using for decryption, something that can be done over the config server’s HTTP API:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://$ManagerIP:8888/encrypt -d 'password'
AQClKEMzqsGiVpKx+Vx6vz+7ww00n... (rest omitted for brevity)
</code></pre></div></div>

<h1 id="viper">Viper</h1>
<p>Our Go-based configuration framework of choice is <a href="https://github.com/spf13/viper">Viper</a>. Viper has a nice API to work with, is extensible and doesn’t get in the way of our normal application code. While Viper doesn’t support loading configuration from Spring Cloud Configuration servers natively, we’ll write a short snippet of code that does this for us. Viper also handles many file types as config source - for example json, yaml and plain properties files. Viper can also read environment variables from the OS for us which can quite neat. Once initialized and populated, our configuration is always available using the various <a href="https://godoc.org/github.com/spf13/viper">viper.Get*</a> functions. Very convenient, indeed.</p>

<p>Remember the picture at the top of this blog post? Well, if not - here it is again:</p>

<p><img src="../../../../../../assets/blogg/goblog/configserver.png" alt="configserver.png" /></p>

<p>We’ll make our microservices do an HTTP request on start, extract the “source” part of the JSON response and stuff that into Viper so we can get the HTTP port for our web server there. Let’s go!</p>

<h2 id="loading-the-configuration">Loading the configuration</h2>
<p>As already demonstrated using curl, we can do a plain HTTP request to the config server where we just need to know our name and our “profile”. We’ll start by adding some parsing of flags to our “accountservice” <em>main.go</em> so we can specify an environment “profile” when starting as well as an optional URI to the config server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var appName = "accountservice"

// Init function, runs before main()
func init() {
        // Read command line flags
        profile := flag.String("profile", "test", "Environment profile, something similar to spring profiles")
        configServerUrl := flag.String("configServerUrl", "http://configserver:8888", "Address to config server")
        configBranch := flag.String("configBranch", "master", "git branch to fetch configuration from")
        flag.Parse()
        
        // Pass the flag values into viper.
        viper.Set("profile", *profile)
        viper.Set("configServerUrl", *configServerUrl)
        viper.Set("configBranch", *configBranch)
}

func main() {
        fmt.Printf("Starting %v\n", appName)

        // NEW - load the config
        config.LoadConfigurationFromBranch(
                viper.GetString("configServerUrl"),
                appName,
                viper.GetString("profile"),
                viper.GetString("configBranch"))
        initializeBoltClient()
        service.StartWebServer(viper.GetString("server_port"))    // NEW, use port from loaded config 
}
</code></pre></div></div>

<p>The  <em>config.LoadConfigurationFromBranch(..)</em> function goes into a new package we’re calling <em>config</em>. Create <em>/goblog/accountservice/config</em> and the following file named <em>loader.go</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Loads config from for example http://configserver:8888/accountservice/test/P8
func LoadConfigurationFromBranch(configServerUrl string, appName string, profile string, branch string) {
        url := fmt.Sprintf("%s/%s/%s/%s", configServerUrl, appName, profile, branch)
        fmt.Printf("Loading config from %s\n", url)
        body, err := fetchConfiguration(url)
        if err != nil {
                panic("Couldn't load configuration, cannot start. Terminating. Error: " + err.Error())
        }
        parseConfiguration(body)
}

// Make HTTP request to fetch configuration from config server
func fetchConfiguration(url string) ([]byte, error) {
        resp, err := http.Get(url)
        if err != nil {
                panic("Couldn't load configuration, cannot start. Terminating. Error: " + err.Error())
        }
        body, err := ioutil.ReadAll(resp.Body)
        return body, err
}

// Pass JSON bytes into struct and then into Viper
func parseConfiguration(body []byte) {
        var cloudConfig springCloudConfig
        err := json.Unmarshal(body, &amp;cloudConfig)
        if err != nil {
                panic("Cannot parse configuration, message: " + err.Error())
        }

        for key, value := range cloudConfig.PropertySources[0].Source {
                viper.Set(key, value)
                fmt.Printf("Loading config property %v =&gt; %v\n", key, value)
        }
        if viper.IsSet("server_name") {
                fmt.Printf("Successfully loaded configuration for service %s\n", viper.GetString("server_name"))
        }
}
   
// Structs having same structure as response from Spring Cloud Config
type springCloudConfig struct {
        Name            string           `json:"name"`
        Profiles        []string         `json:"profiles"`
        Label           string           `json:"label"`
        Version         string           `json:"version"`
        PropertySources []propertySource `json:"propertySources"`
}

type propertySource struct {
        Name   string                 `json:"name"`
        Source map[string]interface{} `json:"source"`
}
</code></pre></div></div>

<p>Basically, we’re doing that HTTP GET to the config server with our appName, profile and git branch, then unmarshalling the response JSON into the <em>springCloudConfig</em> struct we’re declaring in the same file. Finally, we’re simply iterating over all the key-value pairs in the <em>cloudConfig.PropertySources[0]</em> and stuffing each pair into viper so we can access them whenever we want using <em>viper.GetString(key)</em> or another of the typed getters the Viper API provides.</p>

<p>Note that if we have an issue contacting the configuration server or parsing its response, we panic() the entire microservice which will kill it. Docker Swarm will detect this and try to deploy a new instance in a few seconds. The typical reason for a behaviour such as this is when starting your cluster from cold and the Go-based microservice will start much faster than the Spring Boot-based config server does. Let Swarm retry a few times and things should sort themselves out.</p>

<p>We’ve split the actual work up into one public function and a few package-scoped ones for easier unit testing. The unit test for checking so we can transform JSON into actual viper properties looks like this using the GoConvey style of tests:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func TestParseConfiguration(t *testing.T) {

        Convey("Given a JSON configuration response body", t, func() {
                var body = `{"name":"accountservice-dev","profiles":["dev"],"label":null,"version":null,"propertySources":[{"name":"file:/config-repo/accountservice-dev.yml","source":{"server_port":6767"}}]}`

                Convey("When parsed", func() {
                        parseConfiguration([]byte(body))
                        
                        Convey("Then Viper should have been populated with values from Source", func() {
                                So(viper.GetString("server_port"), ShouldEqual, "6767")
                        })
                })
        })
}
</code></pre></div></div>

<p>Run from <em>goblog/accountservice</em> if you want to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; go test ./...
</code></pre></div></div>

<h2 id="updates-to-the-dockerfile">Updates to the Dockerfile</h2>

<p>Given that we’re loading the configuration from an external source, our service needs a hint about where to find it. That’s performed by using flags as command-line arguments when starting the container and service:</p>

<p><em>goblog/accountservice/Dockerfile</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM iron/base
EXPOSE 6767

ADD accountservice-linux-amd64 /
ADD healthchecker-linux-amd64 /

HEALTHCHECK --interval=3s --timeout=3s CMD ["./healthchecker-linux-amd64", "-port=6767"] || exit 1
ENTRYPOINT ["./accountservice-linux-amd64", "-configServerUrl=http://configserver:8888", "-profile=test", "-configBranch=P8"]
</code></pre></div></div>

<p>Our ENTRYPOINT now supplies values making it possible to configure from where to load configuration.</p>

<h1 id="into-the-swarm">Into the Swarm</h1>

<p>You probably noted that we’re not using 6767 as a hard-coded port number anymore, i.e:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service.StartWebServer(viper.GetString("server_port"))
</code></pre></div></div>

<p>Use the <em>copyall.sh</em> script to build and redeploy the updated “accountservice” into Docker Swarm</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./copyall.sh
</code></pre></div></div>

<p>After everything’s finished, the service should still be running exactly as it did before you started on this part of the blog series, with the exception that it actually picked its HTTP port from an external and centralized configuration server rather than being hard-coded into the compiled binary.</p>

<p><em>(Do note that ports exposed in Dockerfiles, Healthcheck CMDs and Docker Swarm “docker service create” statements doesn’t know anything about config servers. In a CI/CD pipeline, you’d probably externalize relevant properties so they are injectable by the build server at build time.)</em></p>

<p>Let’s take a look at the log output of our accountservice:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker logs -f [containerid]
Starting accountservice
Loading config from http://configserver:8888/accountservice/test/P8
Loading config property the_password =&gt; password
Loading config property server_port =&gt; 6767
Loading config property server_name =&gt; Accountservice TEST
Successfully loaded configuration for service Accountservice TEST
</code></pre></div></div>

<p><em>(To actually print config values is a bad practice, the output above is just for educational reasons!)</em></p>

<h1 id="live-configuration-updates">Live configuration updates</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- "Oh, did that external service we're using for [some purpose] change their URL?"     
- "Darn. None told us!!" 
</code></pre></div></div>

<p>I assume many of us have encountered situations where we need to either rebuild an entire application or at least restart it to update some invalid or changed configuration value. Spring Cloud has the concept of <a href="https://github.com/dangdangdotcom/config-toolkit/wiki/Refresh-bean-with-spring-cloud's-@RefreshScope-support">@RefreshScope</a>s where beans can be live-updated with changed configuration propagated from a <a href="https://git-scm.com/book/gr/v2/Customizing-Git-Git-Hooks">git commit hook</a>.</p>

<p>This figure provides an overview of how a push to a git repo is propagated to our Go-based microservices:</p>

<p><img src="../../../../../../assets/blogg/goblog/part8-springcloudpush.png" alt="/assets/blogg/goblog/part8-springcloudpush.png" /></p>

<p>In this blog post, we’re using a github repo which has absolutely no way of knowing how to perform a post-commit hook operation to my laptop’s Spring Cloud server, so we’ll emulate a commit hook push using the built-in <em>/monitor</em> endpoint of our Spring Cloud Config server.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -H "X-Github-Event: push" -H "Content-Type: application/json" -X POST -d '{"commits": [{"modified": ["accountservice.yml"]}],"name":"some name..."}' -ki http://$ManagerIP:8888/monitor
</code></pre></div></div>

<p>The Spring Cloud Config server will know what to do with this POST and send out a <em>RefreshRemoteApplicationEvent</em> on an <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">exchange</a> on RabbitMQ (abstracted by Spring Cloud Bus). If we take a look at the RabbitMQ admin GUI after having booted Spring Cloud Config successfully, that <em>exchange</em> should have been created:</p>

<p><img src="../../../../../../assets/blogg/goblog/part8-springcloudbusexchange.png" alt="Exchange name" /></p>

<p>How does an <em>exchange</em> relate to more traditional messaging constructs such as publisher, consumer and queue?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Publisher -&gt; Exchange -&gt; (Routing) -&gt; Queue -&gt; Consumer
</code></pre></div></div>

<p>I.e - a message is published to an <em>exchange</em>, which then distributes message copies to <em>queue(s)</em> based on <em>routing</em> rules and bindings which may have registered <em>consumers</em>.</p>

<p>So in order to consume <em>RefreshRemoteApplicationEvent</em> messages (I prefer to call them <em>refresh tokens</em>), all we have to do now is make our Go service listen for such messages on the <em>springCloudBus</em> exchange and if we are the targeted application, perform a configuration reload. Let’s do that.</p>

<h2 id="using-the-amqp-protocol-to-consume-messages-in-go">Using the AMQP protocol to consume messages in Go</h2>
<p>The RabbitMQ broker can be accessed using the AMQP protocol. There’s a good Go AMQP client we’re going to use called <a href="https://github.com/streadway/amqp">streadway/amqp</a>.
Most of the AMQP / RabbitMQ plumbing code should go into some reusable utility, perhaps we’ll refactor that later on. The plumbing code is based on <a href="https://github.com/streadway/amqp/blob/master/_examples/simple-consumer/consumer.go">this example</a> from the streadway/amqp repo.</p>

<p>In <em>/goblog/accountservice/main.go</em>, add a new line inside the <em>main()</em> function that will start an AMQP consumer for us:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func main() {
        fmt.Printf("Starting %v\n", appName)

        config.LoadConfigurationFromBranch(
                viper.GetString("configServerUrl"),
                appName,
                viper.GetString("profile"),
                viper.GetString("configBranch"))
        initializeBoltClient()
        
        // NEW
        go config.StartListener(appName, viper.GetString("amqp_server_url"), viper.GetString("config_event_bus"))   
        service.StartWebServer(viper.GetString("server_port"))
}
</code></pre></div></div>

<p>Note the new <em>amqp_server_url</em> and <em>config_event_bus</em> properties, they’re loaded from the <a href="https://raw.githubusercontent.com/eriklupander/go-microservice-config/P8/accountservice-test.yml">_accountservice-test.yml</a> configuration file we’re loading.</p>

<p>The <em>StartListener</em> function goes into a new file <em>/goblog/accountservice/config/events.go</em>. This file has a <em>lot</em> of AMQP boilerplate which we’ll skip so we concentrate on the interesting parts:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func StartListener(appName string, amqpServer string, exchangeName string) {
        err := NewConsumer(amqpServer, exchangeName, "topic", "config-event-queue", exchangeName, appName)
        if err != nil {
                log.Fatalf("%s", err)
        }

        log.Printf("running forever")
        select {}   // Yet another way to stop a Goroutine from finishing...
}
</code></pre></div></div>

<p>The NewConsumer function is where all the boilerplate goes. We’ll skip down to the code that actually processes an incoming message:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> func handleRefreshEvent(body []byte, consumerTag string) {
         updateToken := &amp;UpdateToken{}
         err := json.Unmarshal(body, updateToken)
         if err != nil {
                 log.Printf("Problem parsing UpdateToken: %v", err.Error())
         } else {
                 if strings.Contains(updateToken.DestinationService, consumerTag) {
                         log.Println("Reloading Viper config from Spring Cloud Config server")
 
                         // Consumertag is same as application name.
                         LoadConfigurationFromBranch(
                                 viper.GetString("configServerUrl"),
                                 consumerTag,
                                 viper.GetString("profile"),
                                 viper.GetString("configBranch"))
                 }
         }
 }
 
 type UpdateToken struct {
         Type string `json:"type"`
         Timestamp int `json:"timestamp"`
         OriginService string `json:"originService"`
         DestinationService string `json:"destinationService"`
         Id string `json:"id"`
 }
</code></pre></div></div>

<p>This code tries to parse the inbound message into an <em>UpdateToken</em> struct and if the destinationService matches our consumerTag (i.e. the appName “accountservice”), we’ll call the same <em>LoadConfigurationFromBranch</em> function initially called when the service started.</p>

<p>Please note that in a real-life scenario, the <em>NewConsumer</em> function and general message handling code would need more work with error handling, making sure only the appropriate messages are processed etc.</p>

<h2 id="unit-testing">Unit testing</h2>

<p>Let’s write a unit test for the <em>handleRefreshEvent()</em> function. Create a new test file <em>/goblog/accountservice/config/events_test.go</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var SERVICE_NAME = "accountservice"

func TestHandleRefreshEvent(t *testing.T) {
        // Configure initial viper values
        viper.Set("configServerUrl", "http://configserver:8888")
        viper.Set("profile", "test")
        viper.Set("configBranch", "master")

        // Mock the expected outgoing request for new config
        defer gock.Off()
        gock.New("http://configserver:8888").
                Get("/accountservice/test/master").
                Reply(200).
                BodyString(`{"name":"accountservice-test","profiles":["test"],"label":null,"version":null,"propertySources":[{"name":"file:/config-repo/accountservice-test.yml","source":{"server_port":6767,"server_name":"Accountservice RELOADED"}}]}`)

        Convey("Given a refresh event received, targeting our application", t, func() {
                var body = `{"type":"RefreshRemoteApplicationEvent","timestamp":1494514362123,"originService":"config-server:docker:8888","destinationService":"accountservice:**","id":"53e61c71-cbae-4b6d-84bb-d0dcc0aeb4dc"}
`
                Convey("When handled", func() {
                        handleRefreshEvent([]byte(body), SERVICE_NAME)

                        Convey("Then Viper should have been re-populated with values from Source", func() {
                              So(viper.GetString("server_name"), ShouldEqual, "Accountservice RELOADED")
                        })
                })
        })
}
</code></pre></div></div>

<p>I hope the BDD-style of GoConvey conveys (pun intended!) how the test works. Note though how we use <em>gock</em> to intercept the outgoing HTTP request for new configuration and that we pre-populate viper with some initial values.</p>

<h2 id="running-it">Running it</h2>
<p>Time to test this. Redeploy using our trusty <em>copyall.sh</em> script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; ./copyall.sh
</code></pre></div></div>

<p>Check the log of the <em>accountservice</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker logs -f [containerid]
Starting accountservice
... [truncated for brevity] ...
Successfully loaded configuration for service Accountservice TEST    &lt;-- LOOK HERE!!!!
... [truncated for brevity] ...
2017/05/12 12:06:36 dialing amqp://guest:guest@rabbitmq:5672/
2017/05/12 12:06:36 got Connection, getting Channel
2017/05/12 12:06:36 got Channel, declaring Exchange (springCloudBus)
2017/05/12 12:06:36 declared Exchange, declaring Queue (config-event-queue)
2017/05/12 12:06:36 declared Queue (0 messages, 0 consumers), binding to Exchange (key 'springCloudBus')
2017/05/12 12:06:36 Queue bound to Exchange, starting Consume (consumer tag 'accountservice')
2017/05/12 12:06:36 running forever
</code></pre></div></div>

<p>Now, we’ll make a change to the <em>accountservice-test.yml</em> file on my git repo and then fake a commit hook using the <em>/monitor</em> API POST shown earlier in this blog post:</p>

<p>I’m changing <em>accountservice-test.yml</em> and its <em>service_name</em> property, from <em>Accountservice TEST</em> to <em>Temporary test string!</em> and pushing the change.</p>

<p>Next, use curl to let our Spring Cloud Config server know about the update:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; curl -H "X-Github-Event: push" -H "Content-Type: application/json" -X POST -d '{"commits": [{"modified": ["accountservice.yml"]}],"name":"what is this?"}' -ki http://192.168.99.100:8888/monitor
</code></pre></div></div>

<p>If everything works, this should trigger a <em>refresh token</em> from the Config server which our <em>accountservice</em> picks up. Check the log again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; docker logs -f [containerid]
2017/05/12 12:13:22 got 195B consumer: [accountservice] delivery: [1] routingkey: [springCloudBus] {"type":"RefreshRemoteApplicationEvent","timestamp":1494591202057,"originService":"config-server:docker:8888","destinationService":"accountservice:**","id":"1f421f58-cdd6-44c8-b5c4-fbf1e2839baa"}
2017/05/12 12:13:22 Reloading Viper config from Spring Cloud Config server
Loading config from http://configserver:8888/accountservice/test/P8
Loading config property server_port =&gt; 6767
Loading config property server_name =&gt; Temporary test string!
Loading config property amqp_server_url =&gt; amqp://guest:guest@rabbitmq:5672/
Loading config property config_event_bus =&gt; springCloudBus
Loading config property the_password =&gt; password
Successfully loaded configuration for service Temporary test string!      &lt;-- LOOK HERE!!!!
</code></pre></div></div>

<p>As you can see, the final line now prints <em>“Successfully loaded configuration for service Temporary test string!”</em>. The source code for that line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if viper.IsSet("server_name") {
        fmt.Printf("Successfully loaded configuration for service %s\n", viper.GetString("server_name"))
}    
</code></pre></div></div>

<p>I.e - we’ve dynamically changed a property value previously stored in Viper during runtime without touching our service! This IS really cool!!</p>

<p><strong>Important note:</strong>
While updating properties dynamically is very cool, that in itself won’t update things like the port of our <em>running</em> web server, existing Connection objects in pools or (for example) the active connection to the RabbitMQ broker. Those kinds of “already-running” things takes a lot more care to restart with new config values and is out of scope for this particular blog post.</p>

<p><em>(Unless you’re set things up with your own git repo, this demo isn’t reproducible but I hope you enjoyed it anyway.)</em></p>

<h1 id="footprint-and-performance">Footprint and performance</h1>
<p>Adding loading of configuration at startup shouldn’t affect runtime performance at all and it doesn’t. 1K req/s yields the same latencies, CPU &amp; memory use as before. Just take my word for it or try yourself. We’ll just take quick peek at memory use after first startup:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONTAINER                                    CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
accountservice.1.pi7wt0wmh2quwm8kcw4e82ay4   0.02%               4.102MiB / 1.955GiB   0.20%               18.8kB / 16.5kB     0B / 1.92MB         6
configserver.1.3joav3m6we6oimg28879gii79     0.13%               568.7MiB / 1.955GiB   28.41%              171kB / 130kB       72.9MB / 225kB      50
rabbitmq.1.kfmtsqp5fnw576btraq19qel9         0.19%               125.5MiB / 1.955GiB   6.27%               6.2MB / 5.18MB      31MB / 414kB        75
quotes-service.1.q81deqxl50n3xmj0gw29mp7jy   0.05%               340.1MiB / 1.955GiB   16.99%              2.97kB / 0B         48.1MB / 0B         30
</code></pre></div></div>

<p>Even with AMQP integration and Viper as configuration framework, we have an initial footprint of ~4 mb. Our Spring Boot-based <em>config server</em> uses over 500 mb of RAM while RabbitMQ (which I think is written in Erlang?) uses 125 mb.</p>

<p>I’m fairly certain we can starve the config server down to 256 mb initial heap size using some standard JVM -xmx args but it’s nevertheless definitely a lot of RAM. However, in a production environment I would expect us running ~2 config server instances, not tens or hundreds. When it comes to the supporting services from the Spring Cloud ecosystem, memory use isn’t such a big deal as we usually won’t have more than one or a few instances of any such service.</p>

<h1 id="summary">Summary</h1>
<p>In this part of the Go microservices <a href="../../../02/17/go-blog-series-part1.html">blog series</a> we deployed a Spring Cloud Config server and its RabbitMQ dependency into our Swarm. Then, we wrote a bit of Go code that using plain HTTP, JSON and the Viper framework loads config from the config server on startup and feeds it into Viper for convenient access throughout our microservice codebase.</p>

<p>In the <a href="../../../06/08/go-blog-series-part9.html">next part</a>, we’ll continue to explore AMQP and RabbitMQ, going into more detail and take a look at sending some messages ourselves.</p>









            <div class="ce-blog-thanks">
              Tack för att du läser Callistas blogg. <br>
              Hjälp oss att nå ut med information genom att dela nyheter och artiklar i ditt nätverk.<br>
            </div>

            


    
<div class="ce-blog-share">
    <a class="ce-blog-share-element social-twitter" href="https://twitter.com/intent/tweet?text=Go Blog Series Part8&url=https://callistaenterprise.se/blogg/teknik/2017/05/15/go-blog-series-part8/&via=callistaent&hashtags=" target="_blank" title="Share this post on Twitter"></a>
    <a class="ce-blog-share-element social-facebook" href="https://www.facebook.com/sharer/sharer.php?t=Go Blog Series Part8&u=https://callistaenterprise.se/blogg/teknik/2017/05/15/go-blog-series-part8/" target="_blank" title="Share this post on Facebook"></a>
    <a class="ce-blog-share-element social-linkedin" href="http://www.linkedin.com/shareArticle?mini=true&title=Go Blog Series Part8&url=https://callistaenterprise.se/blogg/teknik/2017/05/15/go-blog-series-part8/&source=http%3a%2f%2fzhangwenli.com" target="_blank" title="Share this post on LinkedIn"></a>
</div>
    
        </article>
    </div>
</section>


<section class="ce-section">
    <heading>
        <h1>Kommentarer</h1>
    </heading>
    <div class="ce-content">
        <div id="disqus_thread"></div>
        <script src="../../../../../../js/disqus.js"></script>
    </div>
</section>


    </div>

    <footer class="ce-footer">
    <div class="ce-wrapper">
        <nav class="ce-menu-footer-primary">
            <h2><a href="../../../../../../index.html">Callista</a></h2>
            <ul>
                
                <li><a href="../../../../../../om/index.html">Om oss</a></li>
                
                <li><a href="../../../../../../erbjudanden.html">Erbjudanden</a></li>
                
                <li><a href="../../../../../../event.html">Event</a></li>
                
                <li><a href="../../../../../../blogg.html">Blogg</a></li>
                
                <li><a href="../../../../../../om/jobb/index.html">Jobba hos oss</a></li>
                

                
                    
                        <li><a href="../../../../../../english/index.html">English</a></li>
                    
                
            </ul>
        </nav>
        <div class="ce-addresses">
            <div class="ce-address">
                <h2>Stockholm</h2>
                <address>
                    Drottninggatan 55<br>
                    111 21 Stockholm<br>
                    Tel:
                    <a href="tel:+468212142">
                        +46 8 21 21 42
                    </a>
                </address>
            </div>
            <div class="ce-address">
                <h2>Göteborg</h2>
                <address>
                    Fabriksgatan 13<br>
                    412 50 Göteborg<br>
                    Tel:
                    <a href="tel:+4631201918">
                        +46 31 20 19 18
                    </a>
                </address>
            </div>
        </div>
        <div class="ce-social">
            <h2>Följ oss</h2>
            <ul>
                <li>
                    <a href="http://twitter.com/callistaent">
                        <img alt="Twitters logotype" src="../../../../../../images/icons/twitter.png">
                        <span>@callistaent</span>
                    </a>
                </li>
            </ul>
        </div>
        <small>&copy; 2021 Callista Enterprise AB</small>
        <hr style="margin: 1em 0 2em 0">
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-raddabarnen" href="http://www.raddabarnen.se/foretag">
                <img alt="Callista är Rädda Barnens företagsvän 2021" src="../../../../../../images/logotype/rb_vanforetag_2021_large-sv.png">
            </a>
          </div>
        </div>
        <br>
        <div class="ce-footer-images">
          <div class="ce-footer-image">
            <a class="ce-di-gasell" href="http://www.di.se/gasell/">
              <img alt="Callista utsett till DI Gasell tre år i rad" src="../../../../../../images/logotype/di_gasell_180x194.png">
            </a>
          </div>
        </div>
    </div>
</footer>


    <script src="../../../../../../js/lib/jquery.min.js"></script>
    <script src="../../../../../../js/lib/owl.carousel.min.js"></script>
    <script src="../../../../../../js/lib/prismjs.min.js"></script>
    <script src="../../../../../../js/app.js"></script>
    <script src="../../../../../../js/analytics.js"></script>
    <script src="../../../../../../js/jobinterestsubmit.js"></script>

</body>
</html>
